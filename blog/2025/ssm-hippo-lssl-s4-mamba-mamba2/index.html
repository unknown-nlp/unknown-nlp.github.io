<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="5EvH841dAH-gE3azIorT3dCfBA_7a3yppKdAm1JWne8"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> SSM → HIPPO → LSSL → S4 → Mamba → Mamba2 | Unknown NLP Lab </title> <meta name="author" content="Jeahee Kim"> <meta name="description" content="논문 리뷰"> <meta name="keywords" content="natural language processing, NLP, machine learning, artificial intelligence, research papers, academic collaboration, paper review, computational linguistics, deep learning, transformers, language models"> <meta property="og:site_name" content="Unknown NLP Lab"> <meta property="og:type" content="article"> <meta property="og:title" content="Unknown NLP Lab | SSM → HIPPO → LSSL → S4 → Mamba → Mamba2"> <meta property="og:url" content="https://unknown-nlp.github.io/blog/2025/ssm-hippo-lssl-s4-mamba-mamba2/"> <meta property="og:description" content="논문 리뷰"> <meta property="og:locale" content="en"> <meta name="twitter:card" content="summary"> <meta name="twitter:title" content="SSM → HIPPO → LSSL → S4 → Mamba → Mamba2"> <meta name="twitter:description" content="논문 리뷰"> <script type="application/ld+json">
    {
        "author":
        {
            "@type": "Person",
            "name": "Jeahee Kim"
        },
        "url": "https://unknown-nlp.github.io/blog/2025/ssm-hippo-lssl-s4-mamba-mamba2/",
        "@type": "BlogPosting",
        "description": "논문 리뷰",
        "headline": "SSM → HIPPO → LSSL → S4 → Mamba → Mamba2",
        
        "sameAs": ["https://inspirehep.net/authors/1010907","https://scholar.google.com/citations?user=qc6CJjYAAAAJ","https://www.alberteinstein.com/"],
        
        "name": "Jeahee Kim",
        "@context": "https://schema.org"
    }
  </script> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://unknown-nlp.github.io/blog/2025/ssm-hippo-lssl-s4-mamba-mamba2/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Unknown NLP Lab </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/books/">bookshelf</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">SSM → HIPPO → LSSL → S4 → Mamba → Mamba2</h1> <p class="post-meta"> Created on February 04, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/attention"> <i class="fa-solid fa-hashtag fa-sm"></i> attention</a>   <a href="/blog/tag/bert"> <i class="fa-solid fa-hashtag fa-sm"></i> bert</a>   <a href="/blog/tag/language-model"> <i class="fa-solid fa-hashtag fa-sm"></i> language-model</a>   <a href="/blog/tag/llm"> <i class="fa-solid fa-hashtag fa-sm"></i> llm</a>   <a href="/blog/tag/neural"> <i class="fa-solid fa-hashtag fa-sm"></i> neural</a>   <a href="/blog/tag/nlp"> <i class="fa-solid fa-hashtag fa-sm"></i> nlp</a>   <a href="/blog/tag/paper-review"> <i class="fa-solid fa-hashtag fa-sm"></i> paper-review</a>   <a href="/blog/tag/transformer"> <i class="fa-solid fa-hashtag fa-sm"></i> transformer</a>   ·   <a href="/blog/category/paper-reviews"> <i class="fa-solid fa-tag fa-sm"></i> paper-reviews</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p><strong>논문 정보</strong></p> <ul> <li> <strong>Date</strong>: 2025-02-04</li> <li> <strong>Reviewer</strong>: hyowon Cho</li> </ul> <blockquote> <p>구글에서 공개된 titans가 뜨거운 감자네요. 리뷰를 하려고 열어봤는데, 이미 준원이가 찜해놓기도 하고 + State space model에 대한 사전 지식이 저에게는 부족해서.. 해당 논문에서 주되게 언급되는 Mamba&amp;Mamba2 연구를 가져왔습니다! titans를 향한 여정으로 받아들여주시면 좋을 듯 합니당.</p> </blockquote> <h1 id="background">BackGround</h1> <p>Google titans 모델이 등장하자마자 뜨거운 관심을 모으고 있습니다. 가장 큰 특징이라고 한다면, 헤게모니 아키텍쳐인 transformer가 아닌 sequential modeling을 베이스로 하는 아키텍쳐를 사용해서 transformer에 준하는 성능을 내고 있다는 것입니다.</p> <p>이러한 관점이 titans에서 처음으로 시작된 것은 아닙니다. titans 이전에 State Space Model(SSM)을 활용한 mamba 모델이 sequential modeling의 주류를 차지하고 있었습니다. (titans에서도 mamba-based model들을 주 baseline 모델로 언급합니다)</p> <blockquote> <p>[State Space Model 기반의 efficient architecture 의 계보]</p> </blockquote> <p><strong>HIPPO → LSSL → S4 → Mamba → Mamba2 → Samba, …</strong></p> <p>개인적으로 대단한 것은 HIPPO부터 Mamba2까지 모두 CMU에 계신 Albert Gu 교수님이 모두 1저자로 작성하셨다는 것입니다. 따라서, 해당 흐름을 좇다보면 Albert Gu가 어떠한 아이디어를 기반으로 어떠한 한계를 해결하고자했는지 이해하기 용이할 것입니다.</p> <p>따라서, 본 발표에서는 SSM의 개념을 소개하고, HIPPO부터 Mamba2까지 Albert Gu 교수님의 머릿속을 탐방해보는 시간을 가지도록 하겠습니다.</p> <p>SSM으로 대표되는 sequential model들을 설명하기 이전에 먼저, 왜 transformer 이외의 아키텍쳐 연구가 필요한지 알아보겠습니다.</p> <h2 id="왜-transformer-이외의-아키텍쳐가-필요한가">왜 Transformer 이외의 아키텍쳐가 필요한가</h2> <h3 id="기존-transformer의-문제점-inference-cost"><strong>기존 Transformer의 문제점: Inference Cost</strong></h3> <p>Transformer는 Attention 메커니즘은 다음과 같은 특징을 가집니다:</p> <ul> <li> <p>Attention은 근본적으로 전체 시퀀스에 대한 정보를 축약해 전달받는 것이 아닌, 각각의 정보에 알아서 접근하는 시스템. 따라서, 이전 time-step에 대한 모델의 예측값은 다음 time-stpe의 모델의 예측 값과 상관없음</p> </li> <li> <p><strong>Training</strong></p> <ul> <li>한번의 forward로 모든 time-step에 대한 훈련이 가능하기에<strong>_ 빠른 훈련! _</strong> </li> </ul> </li> <li> <p><strong>Inference</strong></p> <ul> <li> <p>학습 자체는 빠르게 진행되나, inference 시에도 불필요한 정보들에 모두 attend하기 때문에 메모리+속도 이슈 발생</p> <ul> <li> <p><strong><em>시퀀스 길이에 따라 계산 복잡도가 Quadratic하게 증가하여</em></strong>, 긴 시퀀스 데이터를 다룰 때 매우 비효율적</p> </li> <li> <p>inference시 하나의 토큰을 생성하는데 걸리는 시간이 linear하게 늘어남 + attend해야하는 state의 수 또한 Linear하게 늘어남</p> </li> </ul> </li> </ul> </li> </ul> <p>이러한 문제를 해결하기 위해 많은 연구자들이 Linear Attention과 같은 다양한 방법을 제안했지만, 대부분은Transformer만큼의 성능을 내지 못했습니다. 또한, Streaming LLM과 같은 방식으로 inference cost를 낮추기 위한 연구들도 다양하게 존재하지만, 근본적인 해결이 되지는 않았죠.</p> <h3 id="대항마-sequential-models">대항마: <strong>Sequential</strong> Models</h3> <p>연구자들은 다시 Recurrent model들을 살펴보기 시작합니다. Transformer가 Recurrent 모델의 대안으로 등장한 만큼, 둘은 상반된 장점과 단점을 가집니다.</p> <p>Recurrent model들은 모두 알다시피 학습 속도가 매우 느리고, 한정된 공간에 정보를 저장하다보니 해당 지식을 유지하는데 문제가 있습니다:</p> <ul> <li> <p>하나하나 보기보다는 한정된 메모리에 시퀀스 정보를 잘 모아놓는 방식. 이전 t-1에 대한 메모리가 t의 입력으로 필요함</p> </li> <li> <p><strong>Training</strong></p> <ul> <li>sequential → slow training</li> </ul> </li> <li> <p><strong>Inference</strong></p> <ul> <li>그러나, 출력값이 이전 시점의 메모리와 현재의 입력에만 의존하기에(선형적), 토큰 당 생성 속도 및 VRAM 요구치가 constant하다는 장점</li> </ul> </li> </ul> <p>즉, Recurrent 모델이 transformer의 대항마로써 인정받기 위해서는 다음의 두 가지 문제를 해결해야 합니다.</p> <ol> <li> <p>**‘어떻게 한정된 공간 안에 정보를 잘 집어넣어 성능을 transformer만큼 유지할 것인가’ **</p> </li> <li> <p>데이터의 시간적 연속성(time continuity)을 유지하면서도 이를 효과적으로 처리할 수 있는 모델</p> </li> <li> <p>학습 과정에서 발생하는 Vanishing Gradient 문제를 해결</p> </li> <li> <p><strong>‘**</strong>어떻게 학습 속도를 빠르게 만들 것인가’**</p> </li> </ol> <p>그리고 이 두 가지를 해결할 수 있는 실마리가 바로 다음과 같습니다:</p> <ol> <li> <p>한정된 공간 내 지식 압축→ Structured SSM</p> </li> <li> <p>훈련 속도 → Parallel Scan</p> </li> </ol> <p>그렇다면 Structured SSM이 무엇인지 알아보기 위해 SSM이 무엇인지부터 개념을 잡아봅시다</p> <h1 id="state-space-model-ssm"><strong>State Space Model (SSM)</strong></h1> <h2 id="overview">Overview</h2> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_000.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><code class="language-plaintext highlighter-rouge">State Space Model(SSM)</code>은 본래 제어 이론에서 유래한 모델로, 시스템의 상태(state)와 출력을 수학적으로 정의한 것입니다.</p> <p>해당 모델은 <strong>연속적인 시간 흐름</strong>에 따라 시스템의 상태를 모델링합니다. 즉, <strong>(1) 시간에 따라 결정되는 함수</strong>와 <strong>(2) 0번째 시점부터 t-1번째까지의 입력</strong>이 주어질 때, t번째의 출력을 예측하기 위한 시스템이라고 보시면 됩니다.</p> <p>이 모델은 입력 데이터(<em>x</em>)를 받아 상태(<em>h</em>)를 계산한 후 이를 출력(<em>y</em>)으로 변환하는 위의 두 가지 주요 방정식으로 정의됩니다.</p> <p>이때 <strong>A</strong>와 <strong>B</strong>는 연속적 시스템을 표현하는 중요한 매트릭스들로, <strong>시간에 따른 시스템의 상태 변화</strong>를 기술합니다.</p> <ul> <li> <p><strong>A</strong>: 상태 변화를 결정하는 매트릭스. 이전 상태 <em>Xt</em>−1에 곱해져서 시스템의 상태가 어떻게 변하는지 정의합니다.</p> </li> <li> <p><strong>B</strong>: 입력을 상태로 변환하는 매트릭스. 입력 <em>Ut</em>를 받아 상태에 반영하는 역할을 합니다.</p> </li> </ul> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_001.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>입력 u(t)와 출력 y(t) 사이를 이어주는 <strong><em>latent space의 feature x(t)</em></strong> (hidden vector)를 구하자!</p> <p>즉, SSM은 <strong>시스템의 입력을 고차원의 잠재 공간(latent space)으로 변환하여 처리</strong>하는 방식으로 동작합니다.</p> <h2 id="details">Details</h2> <p>즉, 우리가 구하고자 하는 것은 <strong><em>latent space의 feature x(t)</em></strong> (hidden vector)인 state. state는 다음과 같이 정의된다:</p> <ul> <li><strong>state</strong></li> </ul> <p>어떤 시점(t=t0)에서의 변수를 알고, 시간이 지난 어느 시점 (t≥t0)에서의 입력을 알아, 입력이 주어진 시점(t≥t0)에서의 시스템의 거동을 완전히 결정할 수 있을 때, 이러한 변수(상태변수)들의 최소집합 h(t) <em>(용어 혼용 주의: 위에서의 x(t))</em></p> <p>Minimum set of variables, known as state variables, that fully describe the system and its response to any given set of inputs</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_002.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>SSM의 가장 큰 특징은 RNN과 CNN의 장점을 결합함으로써 기존 recurrent model들의 단점을 극복하고 있다는 것인데요,</p> <p><strong>SSM은 크게 3가지 Representation으로 표현될 수 있습니다:</strong></p> <ol> <li> <p><strong>연속 표현 (Continuous Representation)</strong></p> </li> <li> <p><strong>순차적 표현 (Recurrent Representation)</strong></p> </li> <li> <p><strong>합성곱 표현 (Convolution Representation)</strong></p> </li> </ol> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_003.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h3 id="1-continuous-representation">1. <strong>Continuous Representation</strong> </h3> <p>가장 먼저 SSM은 <code class="language-plaintext highlighter-rouge">연속 표현(continuous Representation)</code>을 처리할 수 있으며, 이를 통해 시퀀스 데이터의 연속성을 자연스럽게 모델링할 수 있습니다.</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_004.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>LTI(linear and time-invariant) 시스템에서는 시스템의 현재 상태를 기술하는 방정식인 **상태 방정식(State equation) **을 1차 선형미분방정식으로 표현 가능합니다.</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_005.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_006.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>비슷한 방식으로 출력값을 표현할 수도 있습니다:</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_007.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>따라서, LTI system을 standard state space form으로 표현하는 모델은 다음과 같습니다:</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_008.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>여기서 각 행렬들의 역할은 다음과 같습니다:</p> <ul> <li> <p>A: 기존 메모리 변환 → 메모리 업데이트</p> </li> <li> <p>B: 입력 변환 → 메모리 업데이트</p> <ul> <li>두 벡터의 합이 즉 메모리의 변화율</li> </ul> </li> <li> <p>C: 기존 지식+새로운 입력을 이용해 업데이트한 새로운 메모리를 이용해 출력값 만드는 변환</p> </li> </ul> <p>이렇게 하면, A,B,C,D를 통해서, 앞서 이야기한 u(t)→y(t)를 이어주는 continuous한 flow h(t) (혹은x(t))를 모델링할 수 있습니다.</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_009.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>하지만, 여기서 반환되는 y는 연속된 시계열 표현(continuous-time representation)입니다. 이를 이산적인 단위를 가지는 시퀀스에서 사용하기 위해서는 discretization 작업을 수행해야 합니다.</p> <h3 id="2-recurrent-representation">2. <strong>Recurrent Representation</strong> </h3> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_010.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>State equation은 continuous flow를 모델링하는 과정. 즉, SSM을 텍스트 차원에서 활용하기 위해서는, <strong>연속 시스템에서 이산 시스템으로의 변환</strong>이 필요합니다.</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_011.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>이산화를 하는데는 여러가지 방법이 있지만, 가장 간단한 방식으로는 다음과 같이, 각 시점에서 상태 공간의 변화를 나타내는 SSM 방식으로 치환할 수 있습니다:</p> <ul> <li> <p><em>h</em>(<em>t</em>)=<strong>A̅</strong>⋅<em>h</em>(<em>t</em>−1)+<strong>B̅</strong>⋅<em>x</em>(<em>t</em>)</p> </li> <li> <p><em>y</em>(<em>t</em>)=<em>C</em>⋅<em>h</em>(<em>t</em>)</p> <ul> <li> <strong>A̅</strong>와 <strong>B̅</strong>는 SSM에서 <strong>이산화</strong> 된 버전의 매트릭스들로, 연속적인 시스템을 이산적인 형태로 변환하여 시퀀스 데이터를 처리할 수 있게 만듬. <strong>A̅</strong>와 <strong>B̅</strong>는 연속적인 SSM 모델의 도함수를 기반으로 이산적 시퀀스 처리에 맞게 변환된 것.</li> </ul> </li> </ul> <p>확인할 수 있듯, Recurrent Representation은 상태 공간 모델에서 순차적으로 상태 <em>h</em>(<em>t</em>) 를 업데이트하는 구조입니다.</p> <p>즉, t번째 시간 단계에서의 상태 <em>h</em>(<em>t</em>)는 이전 상태 <em>h</em>(<em>t</em>−1)에 의존합니다.</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_012.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>이제 이산화한 결과를 살펴보면 다음과 같이 각각의 T=0, T=1, T=2에 대해서 이전 time t-1의 <em>h(t-1)</em>의 input과 현시점 <em>x(t)</em>의 input을 받아서 <em>h(t)</em>를 도출하고 이를 통해 <em>y(t)</em>를 재귀적으로 호출하는 것을 볼 수 있습니다.</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_013.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_014.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>여기서 보면 RNN과 굉장히 유사한 수식이 나오지만, 둘은 본질적으로 다릅니다.</p> <ol> <li>SSM은 이산화하여 형태가 비슷해졌지만, 본질적으로 continuous하다.</li> </ol> <ul> <li> <p>애초에 이산화된 단위를 다루는 RNN,</p> </li> <li> <p>연속적인 flow를 모델링한 뒤, 이산화를 통해 해당 단위에서도 다룰 수 있게 만든 SSM</p> </li> <li> <p><strong>SSM의 장점</strong>은 이러한 연속적인 흐름을 기반으로 시스템의 미세한 변화를 더 잘 모델링할 수 있다는 점.</p> <ul> <li>시간 변화가 연속적인 시스템에서 데이터를 잘 반영할 수 있기 때문에 <strong>시스템의 물리적 성질</strong>을 더 정확하게 반영할 수 있음.</li> </ul> </li> </ul> <ol> <li>SSM은 LTI, 즉 linear하면서도 time-invariant하다는 특징</li> </ol> <ul> <li> <p>non-linearity가 없음 (no activation) → recurrence를 convolutionize할 수 있음 → fast training 가능!</p> </li> <li> <p>즉, y_t를 만들기 위해 앞선 순서를 기다릴 필요가 없이, 다 각각 kernel을 만들어서 수행을 한 다음, 합치면 됨. kernel 길이는 설정하기 나름</p> </li> </ul> <blockquote> <p>그런데 여기서 의문이 생길 수 있는 점은, Linear system에서 구축한 state layer가 과연 일반적인 deep RNN이 가지는 non-linearity 및 복잡도를 표현할 수 있는가에 대한 문제이다.</p> </blockquote> <p><strong>˙x(t)=−x(t)+u(t)</strong>의 이산화를 다르게 해석해서 <em>Picard iteration</em> 을 사용한다고 생각하면, 결국 deep RNN은 학습 과정에서 <em>Picard iteration</em> 을 거치면서 함수를 찾아간다고 생각할 수 있다. 즉, 만약 linear recurrence가 아닌 non-linear recurrence를 사용한다면 LSSL 또한 non-linearity를 학습할 수 있게 된다. 이를 통해 RNN 구조와 LSSL는 필요충분 관계에 놓여있다고 볼 수 있다. (궁금하면 참고: https://junia3.github.io/blog/lssl)</p> <h3 id="3-convolution-representation">3. <strong>Convolution Representation</strong> </h3> <p>위에서 언급했 듯, SSM은 non-linearity가 존재하지 않기 때문에 convolutionize할 수 있습니다.</p> <p>예시를 봅시다:</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_015.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><code class="language-plaintext highlighter-rouge">Convolution Representation</code> 방식의 장점은 Recurrent Representation에서 각 시간 단계별로 순차적으로 상태를 업데이트하는 대신, <strong>모든 시간 단계의 출력을 한 번에 계산할 수 있다</strong>는 점입니다.</p> <ul> <li> <p><strong>병렬 처리 가능</strong>:</p> <ul> <li> <p>Recurrent Representation에서는 각 시간 단계별로 순차적으로 상태를 업데이트해야 하므로 계산이 직렬화되어 있음.</p> </li> <li> <p>Convolution Representation에서는 커널을 이용하여 입력 시퀀스 전체에 걸쳐 동시에 출력을 계산할 수 있어, 병렬화가 가능.</p> </li> </ul> </li> <li> <p><strong>더 큰 커널 적용 가능</strong></p> <ul> <li>더 큰 커널은 더 긴 범위의 과거 입력을 한 번에 처리할 수 있어, 더 넓은 문맥 정보를 활용할 수 있음. 이는 시퀀스 데이터에서 장기적인 종속성을 더 잘 반영하는 데 도움.</li> </ul> </li> <li> <p><strong>계산 효율성</strong></p> <ul> <li>합성곱 연산은 일반적으로 GPU와 같은 병렬화가 가능한 하드웨어에서 매우 빠르게 처리될 수 있음. 이는 Recurrent Representation에 비해 계산 속도에서 큰 이점을 제공.</li> </ul> </li> </ul> <p>여기까지 SSM의 개념에 대해서 알아보았습니다.</p> <p>그렇다면 지금부터 Albert Gu 교수님의 연구들에서 이 SSM의 개념이 어떻게 발전되고 있는지 확인해봅시다.</p> <hr> <h1 id="research-summary">Research Summary</h1> <p>이 논문들은 각각 시계열 데이터를 다루는 <strong>기존 모델의 한계</strong>를 극복하는 중요한 기술적 발전을 담고 있습니다.</p> <ol> <li><strong>HiPPO: Recurrent Memory with Optimal Polynomial Projections (NeurIPS, 2020)</strong></li> </ol> <ul> <li> <strong>목적</strong>: <code class="language-plaintext highlighter-rouge">긴 시퀀스에 대한 메모리 문제를 해결</code>하고, <code class="language-plaintext highlighter-rouge">메모리를 효율적으로 유지하면서 입력 정보를 계속 업데이트</code>하는 방법을 제안합니다.</li> </ul> <ol> <li><strong>LSSL: Combining Recurrent, Convolutional, and Continuous-time Models with Linear State-Space Layers (NeurIPS, 2021)</strong></li> </ol> <ul> <li> <strong>목적</strong>: 이 연구는 <code class="language-plaintext highlighter-rouge">연속 시간 모델과 선형 상태 공간 레이어(LSSL)를 결합</code>하여, <code class="language-plaintext highlighter-rouge">시간에 따른 연속적인 변화와 비연속적인 변화를 동시에 처리</code>할 수 있게 만듭니다.</li> </ul> <ol> <li><strong>S4: Efficiently Modeling Long Sequences with Structured State Spaces (ICLR, 2022)</strong></li> </ol> <ul> <li> <strong>목적</strong>: S4는 LSSL의 computational limit을 개선하기 위해 Convolution Representation의 효율성을 극대화하면서도, <code class="language-plaintext highlighter-rouge">장기적인 종속성을 더 잘 처리할 수 있게 최적화</code>되었습니다.</li> </ul> <ol> <li><strong>Mamba: Linear-Time Sequence Modeling with Selective State Spaces (2023)</strong></li> </ol> <ul> <li> <strong>목적:</strong> S4가 텍스트 데이터에 낮은 성능을 보이는 것을 selection mechanism을 통해서 개선하되, parallel scan을 통해서 속도를 유지합니다. transformer에 준하는 성능을 보입니다.</li> </ul> <ol> <li><strong>(Mamba2)Transformers are SSMs: Generalized Models and Efficient Algorithms Through Structured State Space Duality (ICML, 2024)</strong></li> </ol> <ul> <li>목적: SSM과 어텐션 간의 이론적 연결을 확립하여 두 모델의 상호작용을 이해할 수 있는 <strong>이론적 프레임워크</strong> 제공합니다. 이를 기반으로, Transformer의 최적화 기법을 SSM에 적용해, Mamba의 성능을 크게 향상시킵니다.</li> </ul> <hr> <h1 id="1-hippo-recurrent-memory-with-optimal-polynomial-projections-neurips-2020"><strong>1. HiPPO: Recurrent Memory with Optimal Polynomial Projections (NeurIps 2020)</strong></h1> <blockquote> <p><strong>[GOAL] finite한 공간에 어떻게 시간에 따라 변화하는 데이터를 압축된 형태로 유지하며, 각 시간 t에서 과거 데이터를 효율적으로 표현할 수 있는가?</strong></p> </blockquote> <ul> <li> <p>기억해야하는 funcion f(sequence), 즉, t 시점 이전의 모든 히스토리를 제한된 메모리(hidden state) 내에 잘 압축해서 가지고 있어야 한다.</p> </li> <li> <p>HiPPO는 time series input의 길이가 매우 길 때, 해당 input의 cumulative history를 압축하여 표현하는 방법을 제안한다.</p> </li> </ul> <p>HiPPO는 함수 근사를 위한 일종의 동적 시스템 방법론으로, 주어진 함수 <em>f</em>(<em>t</em>)를 시간에 따라 압축하고 저장하는 과정을 다룹니다.</p> <p>이 과정은 측도(measure)에 기반한 직교 기저를 사용하여 함수를 다항식 공간으로 투영(projection)하고, 시간에 따라 변화하는 함수의 정보를 효율적으로 표현할 수 있도록 설계되었습니다.</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_016.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Time에 따라 변하는 (우리가 기억해야하는) 함수 f(t)가 있다고 하자.</p> <p>(1) <strong>Projection 연산 : 함수 ***</strong>f<strong>*</strong>(<strong>*</strong>t<strong>*</strong>)를 다항식 공간으로 투영**</p> <ul> <li> <p>각 시간 t0, t1 , … T에 따라 optimal하게 projection되는 <strong>polynomial function g(t)가 존재한다고 하자</strong></p> </li> <li> <p>이때, f를 우리가 잘 다룰 수 있는 함수 g에 projection 한다.</p> </li> <li> <p>투영 연산자 proj는 함수 <em>f</em>(<em>t</em>)를 일정 시간 <em>t</em>까지의 정보로 제한하여 다항식 공간 <em>G</em>에 투영합니다. 즉, 주어진 <em>f</em>(<em>t</em>)의 정보를 다항식 <em>g</em>(<em>t</em>)로 근사하여 나타냅니다.</p> </li> <li> <p>g(t) : n orthogonal polynomial basis</p> </li> <li> <p>이때, polynomial 기저공간(subspace)G 에 중요도에 대한 측도 (measure) μ(t)를 가중하여 투영 (projection)한다.</p> </li> <li> <p>정리하자면, 투영을 통해 얻은 다항식이 시간 <em>t</em> 이전의 함수 정보 <em>f</em>≤<em>t</em>(<em>x</em>)를 최대한 정확하게 표현하는 것이 중요하기에, <strong><em>주어진 측도 μ(t) 하에서 오차가 최소화되도록 다항식 g(t)로 함수를 근사하는 것이 목표</em></strong>!</p> </li> </ul> <p>(2) <strong>Coefficients 계산: 계수 ***</strong>c<strong>*</strong>(<strong>*</strong>t<strong>*</strong>) 구하기**</p> <ul> <li> <p>즉, n개의 정규직교하는 다항함수를 가지고 f를 근사하겠다</p> </li> <li> <p>그럼 n개의 함수에 대한 가중치를 생각해볼 수 있음 → 이 가중치가 c(t)</p> <ul> <li> <p>g(t)를 <strong>R^N space vector를 가지는 coef. **c(t)</strong>로 mapping.**</p> </li> <li> <p>잘 정의된 기저 공간에 대해, 얻어진 각 basis에 대한 coefficients c(t)∈\RN 는 함수 f의 history를 잘 압축할 수 있다.</p> </li> <li> <p>c(t)는 즉, f를 g에 projection했을 때, 그 간격을 최소화하는 coefficient</p> </li> </ul> </li> <li> <p>투영된 다항식 <em>g</em>(<em>t</em>)는 다항식 기저 함수들의 선형 결합으로 표현되며, 각 기저 함수에 곱해지는 계수 <em>c</em>(<em>t</em>)는 시간에 따라 변화.</p> </li> <li> <p>HiPPO는 이 계수 <em>c</em>(<em>t</em>)를 효율적으로 계산하여, 함수 <em>f</em>(<em>t</em>)의 과거 기록을 압축하는 방식으로 표현</p> </li> </ul> <p>(3) <strong>미분 방정식 (ODE)으로 계수의 진화 모델링</strong></p> <ul> <li> <p>그렇다면, 이런 좋은 coefficient를 어떻게 얻냐?</p> <ul> <li>적절한 basis와 measure를 선택하게 되면 (A,B→ 훈련의 대상은 아님), c(t)의 업데이트 룰이 해석적으로 도출이 된다. 도함수를 통해 계산된다!</li> </ul> </li> </ul> <p>→ 이는 즉, 어떠한 시점 t에서도 히스토리를, 선정한 polynomial basis상에서 가장 최적으로 projection하는 coefficient를 찾을 수 있다!</p> <ul> <li> <p>투영된 함수의 계수 <em>c</em>(<em>t</em>)는 시간에 따라 진화하며, 이 변화는 상미분 방정식(ODE)으로 표현됩니다:</p> <ul> <li> <p>이 방정식은 계수 <em>c</em>(<em>t</em>)가 시간 <em>t</em>에 따라 어떻게 변화하는지를 설명합니다. <em>A</em>(<em>t</em>)와 <em>B</em>(<em>t</em>)는 각각 계수와 함수의 변화율을 나타내는 행렬.</p> </li> <li> <p>중요한 점은, HiPPO가 이 ODE를 통해 함수를 시간에 따라 온라인 방식으로 압축한다는 것. 즉, 실시간으로 함수의 정보를 저장하고 진화.</p> </li> </ul> </li> </ul> <p>(4) <strong>Discrete-time HiPPO Recurrence (이산 시간 재귀 관계)</strong></p> <ul> <li> <p>해당 시스템을 이산화하면 online으로 추가되는 데이터에 대해 효율적인 closed-form recurrence 시스템을 구성할 수 있다.</p> </li> <li> <p>우리가 다루는 공간은 이산적이므로, 이를 회귀 (recurrence)문제로 다시 정의.</p> </li> <li> <p>measure을 통해서 A와 B matrix를 정의:</p> <ul> <li>projection matrix를 <strong>결정지을 measures에 대해서 기본적인 2가지 transition을 보여주고 있는데 (translated Legendre (LegT), translated Laguerre (LagT)) 현 시점에서는 중요하지 않아 생략!</strong> </li> </ul> </li> <li> <p>이 과정을 통해, HiPPO는 함수의 과거 기록을 선형 결합의 형태로 압축하여 저장하고, 실시간으로 업데이트</p> </li> </ul> <p>그렇다면 얘가 왜 SSM?</p> <p>→ 수식을 잘 보면: <strong>continuous한 g(t)를 구성하는 matrix는 A와 B **(HiPPO framework: </strong>A<strong> * C + </strong>B<em>* </em> f)</p> <p>C=1, D=0으로 고정</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HiPPO</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Linear time invariant x</span><span class="sh">'</span><span class="s"> = Ax + Bu.</span><span class="sh">"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="sh">'</span><span class="s">legt</span><span class="sh">'</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">discretization</span><span class="o">=</span><span class="sh">'</span><span class="s">bilinear</span><span class="sh">'</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        N: the order of the HiPPO projection
        dt: discretization step size - should be roughly inverse to the length of the sequence
        </span><span class="sh">"""</span>

        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>

        <span class="c1"># (1) method를 통해서 measures 정의. (transition 함수)
</span>
        <span class="n">self</span><span class="p">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="n">self</span><span class="p">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span>
        <span class="n">self</span><span class="p">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="n">self</span><span class="p">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">T</span>
        <span class="n">self</span><span class="p">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>

        <span class="c1"># continous한 g(t)를 구성하는 A와 B matrix 정의.
</span>        <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="nf">transition</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">*</span><span class="n">c</span>
        <span class="n">self</span><span class="p">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span>
        <span class="n">self</span><span class="p">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="nf">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">measure_fn</span> <span class="o">=</span> <span class="nf">measure</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="c1"># State Space Model (SSM) 정의를 위한 C와 D를 각각 1과 0으로 설정.
</span>        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,))</span>

        <span class="c1"># 현재 continuous function이므로, 이를 discrete하게 만들어주기 위해 signal.cont2discrete 적용.
</span>        <span class="n">dA</span><span class="p">,</span> <span class="n">dB</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">signal</span><span class="p">.</span><span class="nf">cont2discrete</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">),</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">discretization</span><span class="p">)</span>

        <span class="n">dB</span> <span class="o">=</span> <span class="n">dB</span><span class="p">.</span><span class="nf">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">self</span><span class="p">.</span><span class="nf">register_buffer</span><span class="p">(</span><span class="sh">'</span><span class="s">dA</span><span class="sh">'</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">(</span><span class="n">dA</span><span class="p">))</span> <span class="c1"># (N, N)
</span>        <span class="n">self</span><span class="p">.</span><span class="nf">register_buffer</span><span class="p">(</span><span class="sh">'</span><span class="s">dB</span><span class="sh">'</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">(</span><span class="n">dB</span><span class="p">))</span> <span class="c1"># (N,)
</span>
        <span class="n">self</span><span class="p">.</span><span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">eval_matrix</span> <span class="o">=</span> <span class="nf">basis</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">method</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">N</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">vals</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">c</span><span class="p">)</span> <span class="c1"># (T/dt, N)
</span>        <span class="n">self</span><span class="p">.</span><span class="n">measure</span> <span class="o">=</span> <span class="nf">measure</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">method</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">vals</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">fast</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
	     <span class="c1">#  forward 함수를 통해서, coeff를 계산.
</span>        <span class="sh">"""</span><span class="s">
        inputs : (length, ...)
        output : (length, ..., N) where N is the order of the HiPPO projection
        </span><span class="sh">"""</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">.</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">inputs</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">dB</span> <span class="c1"># (length, ..., N)
</span>
        <span class="k">if</span> <span class="n">fast</span><span class="p">:</span>
            <span class="n">dA</span> <span class="o">=</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">dA</span><span class="p">,</span> <span class="sh">'</span><span class="s">m n -&gt; l m n</span><span class="sh">'</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="n">u</span><span class="p">.</span><span class="nf">size</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">unroll</span><span class="p">.</span><span class="nf">variable_unroll_matrix</span><span class="p">(</span><span class="n">dA</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]).</span><span class="nf">to</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># dA * Ck + dB * f를 통해서 Ck+1을 예측.
</span>        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="nf">linear</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">dA</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">dB</span> <span class="o">*</span> <span class="n">f</span>
            <span class="n">cs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">stack</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div> <p>한줄 요약: <strong>HiPPO는 f(t)에 대해서 fixed probability measure를 통해 N개의 basis functions으로 구성된 polynomal g(t)를 생성하고, g(t)를 통해서 coefficients를 생성하는 f -&gt; u 간의 mapping operator 모델</strong></p> <p>즉, SSM을 학습시키는 것은 아니고, RNN에 결합해서 사용했습니다.</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_017.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <hr> <h1 id="2-lssl-combining-recurrent-convolutional-and-continuous-time-models-with-linear-state-space-layers-neurips-2021"><strong>2. LSSL: Combining Recurrent, Convolutional, and Continuous-time Models with Linear State-Space Layers (NeurIPS, 2021)</strong></h1> <blockquote> <p>[GOAL]  <code class="language-plaintext highlighter-rouge">RNN</code>, <code class="language-plaintext highlighter-rouge">CNN</code>, <code class="language-plaintext highlighter-rouge">NeuralODE</code> 각각의 장점을 살리면서도 각 모델의 단점을 극복하는 새로운 구조인 <strong>Linear State-Space Layer(LSSL)</strong>를 제안. 주요 목표는 <code class="language-plaintext highlighter-rouge">CNN</code>의 <strong>병렬 처리 장점</strong>, <code class="language-plaintext highlighter-rouge">RNN</code>의 <strong>상태 추론 능력</strong>, <code class="language-plaintext highlighter-rouge">NeuralODE</code>의 <strong>시간 척도(Time-scale) 적응력</strong>을 동시에 제공하는 모델을 개발하는 것입니다.</p> </blockquote> <ul> <li> <p>본격적인 SSM 아키텍쳐의 시작</p> </li> <li> <p>SSM만을 stacking하여 sequential modeling</p> </li> <li> <p>convoluation을 통한 fast training + recurrence를 통한 efficient inference</p> </li> </ul> <p><strong>HiPPO 같은 경우에는 Coef.를 계산할 때 A, B, C, D가 fixed state space representation!</strong></p> <p><strong>LSSL은 fixed하지 않는 A, B, C, D를 동시에 활용!</strong></p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_018.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>LSSL은 본격적인 SSM 아키텍쳐의 시작인만큼, 위에서 언급한 3가지 관점의 representation을 처음으로 소개합니다:</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">View 1</code>. <strong>Continuous-time 관점</strong>:</p> <ul> <li> <p>이 모드에서는 <strong>상태 공간 모델</strong>이 <strong>연속적 시간</strong> <em>t</em>에 따라 변하며, 불규칙한 샘플링 데이터도 처리할 수 있습니다. (미분 방정식 형태)</p> </li> <li> <p>식 <em>x</em>˙(<em>t</em>)=<em>Ax</em>(<em>t</em>)+<em>Bu</em>(<em>t</em>)는 상태가 시간에 따라 어떻게 변화하는지 나타내며, 출력은 <em>y</em>(<em>t</em>)=<em>Cx</em>(<em>t</em>)+<em>Du</em>(<em>t</em>)로 정의됩니다.</p> </li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">View 2</code>. <strong>Recurrent 관점</strong>:</p> <ul> <li> <p><strong>이산화(Discretization)</strong>를 통해 <strong>RNN과 같은 형태</strong>로 사용할 수 있으며 시간 간격 Δ<em>t</em>에 따라 상태가 변화하고, 이전 상태 정보 <em>xk</em>−1를 사용하여 현재 상태 <em>xk</em>와 출력을 계산합니다.</p> </li> <li> <p>이를 통해 <strong>무한한 문맥(Unbounded Context)</strong>을 처리할 수 있으며, 효율적인 추론이 가능합니다.</p> </li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">View 3</code>. <strong>Convolutional 관점</strong>:</p> <ul> <li> <p><strong>합성곱적 방식</strong>으로도 표현이 가능합니다. 합성곱 커널 <em>K</em>는 선형 시스템을 기반으로 계산되며, 이를 통해 <strong>입력 시퀀스에 대해 병렬로 처리</strong>할 수 있습니다.</p> </li> <li> <p><strong>CNN과 같이 로컬 정보(Local Information)를 사용</strong>하면서도, <strong>병렬화된 훈련이 가능</strong>하다는 장점이 있습니다.</p> </li> </ul> </li> </ul> <p><strong>즉, LSSL은 Input u_k</strong>가 들어왔을 때,</p> <ul> <li> <p><strong>X<em>k = u_k * B + X</em>k-1 * A</strong></p> <ul> <li> <p>u_k에 B matrix를 곱하고 (linear)</p> </li> <li> <p>이전 hidden state cell의 X_k-1에 A matrix를 곱하고 (linear)</p> </li> </ul> </li> <li> <p><strong>output y<em>k = X_k * C + u</em>k * D</strong></p> </li> <li> <p><strong>이렇게 총 A,B,C,D 4개의 layer parameters를 훈련하면 된다!</strong></p> </li> </ul> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_019.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><strong>A, B, C, D를 각각의 linear layer라고 두고 state space model을 디자인 하게 되는데, **최종적으로 </strong>time step Δt와 A가 모델의 성능과 데이터셋을 예측하는데 중요한 역할**을 한다는 것을 알아냈습니다.</p> <p>→ A matrix는 메모리의 업데이트를 담당. 잘 담는게 중요!</p> <p><strong>→ State matrix A가 학습 가능하도록 설정했을 때,</strong> HiPPO에서 제안한 state matrix A보다 성능이 더 잘 나올 수 있음을 보임.</p> <p>특히, LSSL을 하나의 레이어로 사용하지 않고 <strong>여러 레이어로 쌓아서 보다 깊은 네트워크로 확장</strong>할 수 있다고 합니다:</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">기본 LSSL 구조</code> : LSSL은 R^L→R^L seq-to-seq 매핑을 수행하며, 각각의 LSSL 레이어는 파라미터 <em>A,B,C,D</em>와 time step Δ<em>t</em>로 정의됨. 입력 시퀀스는 H 차원의 피처로 처리되며, 각 피처가 독립적으로 학습.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Layer Stacking</code> : Deep LSSL은 여러 LSSL 레이어를 쌓아서 더 복잡한 시퀀스 데이터를 처리할 수 있음. 각 레이어는 서로 다른 상태 공간 파라미터와 시간 간격을 학습하여, 다차원적인 시간 척도에서 데이터를 처리.</p> </li> </ul> <p>그러나 실제로는, 다음과 같은 문제들이 존재합니다:</p> <ol> <li>연산 메모리 문제 때문에 활용이 어려움</li> </ol> <ul> <li> <p>single input-single output을 만들어내던 A,B,C가 각각 d_model만큼 존재</p> </li> <li> <p>즉, 차원마다 SSM 시스템이 개별적으로 존재 → d model개의 element들은 모두 독립적으로 다뤄짐</p> </li> </ul> <ol> <li>vainishing gradient 문제 존재</li> </ol> <ul> <li> <p>A를 random initialization하면 업데이트가 잘 안된다는 문제 존재 → Hippo 방식으로 A를 initialize</p> <ul> <li>거의 모든 deep SSM 모델들은 A를 Hippo Matirx로 초기화</li> </ul> </li> </ul> <hr> <h1 id="3-s4-efficiently-modeling-long-sequences-with-structured-state-spaces-iclr-2022"><strong>3. S4: Efficiently Modeling Long Sequences with Structured State Spaces (ICLR, 2022)</strong></h1> <p>LSSL 논문에서 언급했듯, SSM은 딥러닝에 적용하기에는 computational burden이 매우 커 practical하지 않습니다.</p> <p>Discrete-time SSM (recurrent SSM)에서 computational cost의 주 요인은 A matrix의 반복된 곱셈 연산입니다.</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_020.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>상태 공간 모델(SSM)의 중요한 문제는, <strong>상태 공간의 크기가 커짐에 따라 연산 복잡도</strong>가 증가한다는 것입니다. 구체적으로, <strong>HiPPO 행렬 ***</strong>A***를 여러 번 곱하는 연산이 복잡도를 증가시키는 주 원인입니다.</p> <ul> <li> <p><em>그림에서 볼 수 있듯, 상태 업데이트를 위해서는 A를 여러번 곱해야함</em></p> </li> <li> <p><em>A</em>를 직접 계산하면 <em>O(N^2L)</em>에 달하는 연산량과 <em>O</em>(<em>NL</em>)의 메모리 공간이 필요. 이는 특히 대규모 시퀀스 모델링에서 병목이 됨.</p> </li> <li> <p>심지어 deepSSM을 적용하기 위해 stacking하여 A가 d_model개 있다고 생각하면 더더욱 computation 적으로는 학습하기 어려운 모델이 되는 것</p> </li> <li> <p><strong>입력</strong>과 <strong>출력</strong>이 <em>d_</em>model 차원으로 확장된다면, 모든 차원을 동시에 처리하기 위해 <strong>하나의 공통된 SSM 매트릭스 **(<em>A</em>,<em>B</em>,<em>C</em>)를 사용하는 것을 생각해볼 수 있지만, 이는 **LTI 시스템</strong>의 요구 사항을 위배. 차원별로 독립적인 처리가 이루어지지 않으면 <strong>차원 간의 상호작용</strong>이 발생하고, 시간에 따라 결과가 달라질 수 있기 때문.</p> </li> </ul> <p><strong>S4(Structured State Spaces)</strong>는 이를 해결하기 위해 상태 공간 모델의 수학적 강점을 유지하면서도, 이를 더 효율적으로 계산할 수 있는 방법을 제공합니다.</p> <ol> <li> <p><strong>대각화 (Motivation: Diagonalization)</strong></p> </li> <li> <p>A를 직접 계산하는 메모리 및 연산 문제는 <strong>켤레(conjugation)</strong>라는 수학적 기법을 도입하여 연산을 단순화할 수 있음</p> </li> <li> <p><strong>Lemma 3.1</strong>에서 상태 공간 모델(SSM)의 행렬 <em>A</em>, <em>B</em>, <em>C</em>에 <strong>켤레 변환</strong>을 적용하면 동일한 모델을 얻을 수 있음을 보여줌. 켤레 변환을 할 시, <strong><em>대각화나 정규형으로의 변환이 가능해짐</em></strong></p> </li> <li> <p><em>*Lemma 3.2: **HiPPO 행렬 </em>A*가 대각화될 수 있음을 보임. 이를 통해 연산을 간소화할 수 있음</p> </li> <li> <p>diagonalization을 통해서 <strong>time-complexity가 O(N^2L)에서 O(NL)까지 줄어드는 것을 확인</strong>할 수 있다!</p> </li> <li> <p><strong>Normal Plus Low-Rank Parameterization (NLPR)</strong></p> </li> <li> <p>그러나 diagonalization을 통해서 A, B, C를 conjugate하는 방법은 아쉽게도 HiPPO matrix에서 numerical issue로 계산이 안 될 수 있음 (대각 행렬이 아니여서)</p> </li> <li> <p>이를 해결하기 위해, 논문에서는 <strong>정규 행렬(normal matrix)</strong>과 <strong>저랭크 행렬(low-rank matrix)</strong>의 합으로 분해하는  <strong>NPLR (Normal Plus Low-Rank) 방법론을 통해</strong> 계산의 안정성과 효율성을 높임.</p> </li> <li> <p>저랭크 행렬의 항목 수가 적기 때문에 이 방법을 사용하면, <em>A</em>를 여러 번 곱하는 연산의 복잡도를 대폭 줄일 수 있음.</p> </li> <li> <p>general하게 모든 SSM 관점에서 (HiPPO matrix도 포함) diagonalization을 통해서 A를 V^{-1}AV와 처럼 표현하기 위해 NPLR을 도입했다고 생각해볼 수 있습니다.</p> </li> </ol> <p>따라서, NPLR을 Lemma 3.1에 대입하게 된다면 SSM은 <strong>(A, B, C) ~ (Diagonal - PQ*, B, C)로 재정의</strong> 할 수 있다. 즉, <strong>S4는 총 5개의 trainable parameters(P, Q, B, C, diagonal)를 훈련</strong>하게 된다!</p> <ol> <li> <p><strong>S4 Algorithms and Computational Complexity</strong></p> </li> <li> <p>S4는 <strong>Cauchy kernel</strong>을 사용하여 효율적인 계산을 가능하게 하며, 이로 인해 긴 시퀀스를 처리하는 데 필요한 연산량과 메모리 사용량을 크게 줄일 수 있음.</p> </li> </ol> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_021.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h2 id="h3-hungry-hungry-hippos-towards-language-modeling-with-state-space-models">H3: Hungry Hungry Hippos: Towards Language Modeling with State Space Models</h2> <p>S4는 continuous한 task에 대해서는 잘하지만 language modeling을 못한다는 문제가 존재했습니다. H3 저자들은 S4가 어떤 task를 못하는지 분석하여 이 원인을 파헤쳐봅니다.</p> <ol> <li> <p>inductive head</p> </li> <li> <p>정해진 special token 뒤에 어던 글자가 왔었는지 기억하고 생성하는 task</p> </li> <li> <p>associative recall</p> </li> <li> <p>여러 Key-value쌍을 기억해서 주어진 Key에 대한 value를 생성해내는 task</p> </li> </ol> <p>이 두 개를 못하기 때문에 S4가 언어모델링을 잘 수행하지 못한다고 주장하며, 두 개의 능력을 심어줌으로써 이를 개선할 수 있다고 주장합니다:</p> <ol> <li> <p>T 시점의 token 정보를 t+m 시점까지도 delay&amp;convey하는 능력</p> </li> <li> <p>지금 시점에 input된 정보를 지금 시점의 memory와 비교하는 능력</p> </li> </ol> <p>이 두 개의 능력은 input에 대해 sequence 방향으로의 Conv1D layer를 추가하는 것으로 쉽게 해결할 수 있다고 주장합니다.</p> <p>(이후 내용은 크게 중요하지 않아 생략)</p> <hr> <h1 id="4-mamba-linear-time-sequence-modeling-with-selective-state-spaces"><strong>4. Mamba: Linear-Time Sequence Modeling with Selective State Spaces</strong></h1> <p>지금까지 언급된 것처럼 SSM은 재귀적 신경망(RNN)과 합성곱 신경망(CNN)의 이점을 결합한 모델로, 시퀀스의 길이에 비례하는 <strong>선형적인 계산 복잡도를 가지고 있어 매우 효율적</strong>입니다.</p> <p>하지만, 많은 고민에도 불구하고 SSM은 정보 밀도가 높은 텍스트 데이터에서는 Transformer만큼의 성능을 내지 못한다는 치명적인 단점이 존재합니다.</p> <p><strong>Mamba</strong>는 <code class="language-plaintext highlighter-rouge">선택 메커니즘</code>을 도입한 <strong>Selective State Space Model(선택적 상태 공간 모델)</strong>을 기반으로 하며, <strong>긴 시퀀스를 다루면서도 Transformer 수준의 성능을 유지</strong>하면서도 계산 비용을 줄일 수 있는 모델입니다.</p> <p>즉, mamba는 S4+selection (S6) 모델! S가 6개여서 mamba라고 이름 붙였다고 하네요. 요런 느낌..</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_022.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <blockquote> <p>물론 transformer만큼 강력하지는 않기 때문에 보편화되지 않았겠죠?! 그래도 대항마라고 엄청 화제가 된 모델인데 ICLR2024 리젝당한 것은 신기한 사실. 실험 결과가 부족하다는 평을 들었다고 하네옹</p> </blockquote> <h2 id="selective-state-space-models-">**Selective State Space Models **</h2> <h3 id="1-motivation-selection-as-a-means-of-compression"><strong>(1) Motivation: Selection as a Means of Compression</strong></h3> <p>H3 논문에서도 언급 되었듯, S4와 같은 LTI 시스템은 language modeling에서는 좋지 않은 성능을 보입니다. 저자들은 이를 해결하기 위해서는 두 가지 task에 대한 능력이 향상되어야 된다고 주장합니다.</p> <ol> <li><strong>Selective Copying Task</strong></li> </ol> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_023.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li> <p>단순히 시퀀스 데이터를 기억하고, 특정 위치에서 복사하는 작업인 <strong>Copying Task</strong>는  <strong>입력과 출력 간의 간격이 일정</strong>하게 유지되기 때문에, <strong>LTI(Linear Time-Invariant) 모델</strong>로 쉽게 처리할 수 있는 단순한 작업.</p> </li> <li> <p><strong>Selective Copying Task</strong>는 Copying Task와 달리, <strong>입력과 출력 간의 간격이 일정하지 않고 랜덤</strong>하게 변동됩니다.</p> <ul> <li> <p>모델은 시퀀스 내에서 <strong>중요한 정보를 선택적으로 기억</strong>하고, 나머지 불필요한 정보는 무시해야 함.</p> </li> <li> <p>hidden ht에 x_t를 선택적으로 update. 특정 토큰만 update!</p> </li> </ul> </li> <li> <p>기존 구조로 가능한가? no!</p> <ul> <li>왜냐면 input에 따라서 action이 달라져야한다는 것인데, 이는 LTI 시스템 상 근본적으로 불가</li> </ul> </li> <li> <p>이 문제를 해결하려면 <strong>시간 가변 모델(Time-Varying Model)</strong>과 <strong>선택적 메커니즘(Selection Mechanism)</strong>이 필요.</p> </li> </ul> <ol> <li><strong>Induction Heads Task</strong></li> </ol> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_024.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li> <p>모델이 이전에 학습된 정보를 바탕으로 <strong>문맥(Context)</strong>을 이해하고, <strong>문맥에 맞는 출력을 유추</strong>하는 task</p> </li> <li> <p><strong>선택적 메커니즘</strong>과 함께 <strong>연관 기억 메커니즘</strong>을 사용하면, 모델이 문맥을 기반으로 필요한 정보를 기억하고, 새로운 입력이 들어올 때 그 정보를 다시 사용할 수 있음</p> </li> </ul> <h3 id="2-improving-ssms-with-selection">(2) <strong>Improving SSMs with Selection</strong> </h3> <p>저자들은 위의 두 가지 task에 대해서 SSM이 잘 작동하게 하기 위해 Selection Mechanism을 도입합니다(<code class="language-plaintext highlighter-rouge">SSM + Selection (S6)</code>).</p> <p>Selection Mechanism은 SSM의 주요 매개변수(time step Δ,<em>B</em>,<em>C</em>) 세 가지를 입력에 따라 선택적으로 변동시킴으로써 시퀀스의 중요한 부분을 선택적으로 기억하고, 불필요한 부분은 무시하게 합니다.</p> <p>당연히, 이 선택 메커니즘은 LTI를 유지하지 않기 때문에 시간에 따라 동적으로 변화하는 시퀀스를 처리할 수 있지만, 이 때문에 kernel의 형태로 <strong><em>병렬화를 할 수 없게 되기에 연산 속도를 위해서 추가적인 알고리즘</em></strong>이 필요합니다.</p> <p>우선, selection mechanism을 적용한 S6를 S4와 비교하며 알아봅시다.</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_025.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><strong>계산 방식</strong>: <code class="language-plaintext highlighter-rouge">선형 재귀</code> 또는 <code class="language-plaintext highlighter-rouge">합성곱 연산</code>을 사용하여 <strong>시간 불변적 처리만 가능</strong></p> <p>S4에는 LTI 시스템이기 때문에, <code class="language-plaintext highlighter-rouge">(D, N)</code>의 고정된 파라미터가 모든 시퀀스에 동일하게 적용됩니다.</p> <ul> <li> <p><strong>파라미터 A, B, C</strong>: <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B</code>, <code class="language-plaintext highlighter-rouge">C</code>는 모두 <code class="language-plaintext highlighter-rouge">(D, N)</code> 형태로 존재하며, 여기서 D는 입력 차원, N은 숨겨진 차원(hidden state). 고정 파라미터.</p> </li> <li> <p><strong>이산화 (discretization)</strong>: continuous 시스템을 이산화하여 A, B 매트릭스의 값을 변환하는 연산을 수행하는데, 이때 사용하는시간 간격 <code class="language-plaintext highlighter-rouge">Δ</code>는 <code class="language-plaintext highlighter-rouge">(D)</code> 크기의 파라미터.</p> </li> <li> <p>S4에서는 고정된 Δ가 사용됩니다. 이산화된 Δ는 각 시퀀스에 대해 각각의 매트릭스 A, B와 곱해져 <em>ht</em>를 업데이트합니다.</p> </li> </ul> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_026.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>S6은 입력 및 출력의 형태는 동일. 차이는 선택 메커니즘을 적용해 입력 데이터에 따라 파라미터가 변화한다는 점!</p> <p>즉, S6에서는 입력 의존적인 선택(selectivity)이 추가되어 시점에 따라 달라지는 방식으로 처리됩니다.</p> <ul> <li> <p><strong>매개변수 변화</strong>:</p> <ol> <li> <p><strong>*B***</strong>, <strong>*</strong>C<em>**: S4에서는 고정된 매개변수였으나, S6에서는 </em>sB<em>(</em>x<em>), </em>sC<em>(</em>x<em>)와 같은 함수로 입력 </em>x*에 따라 변화합니다. 즉, B,C를 직접적으로 학습시키는 것이 아닌 linear operator를 학습.</p> </li> <li> <p><strong>Δ</strong>: S4에서는 고정된 값이었으나, S6에서는 <em>s</em>Δ(<em>x</em>)를 통해 입력에 따라 변화. 이산화된 Δ는 각 시퀀스에 대해 각각의 매트릭스 A, B와 곱해져 <em>ht</em>를 업데이트. 이는 모델이 시점에 따라 가변적인 시간 스케일을 적용할 수 있게 함.</p> </li> </ol> </li> <li> <p><strong>작동 방식</strong>:</p> <ol> <li> <p>매개변수 <em>A</em>, <em>B</em>, <em>C</em>와 시간 스케일 Δ는 입력 데이터 <em>x</em>에 따라 변화합니다. 이를 통해 각 시퀀스마다 다른 매핑이 일어납니다.</p> </li> <li> <p>각 시점에서 재귀적 계산(recurrence)만 수행되며, 이는 시간에 따라 변화하는 <strong>time-varying</strong> 모델입니다. 특히, 각 시퀀스마다 다르게 이산화된 파라미터가 적용되기 때문에 각 토큰에 맞는 연산이 수행됩니다.</p> </li> </ol> </li> </ul> <p>[정리]</p> <ul> <li> <p><strong>입력 의존성</strong></p> <ul> <li> <p><strong>S4</strong>: 고정된 파라미터를 사용하여, 모든 시점에서 동일한 계산을 수행. 즉, 모든 시점에서 동일한 방식으로 입력 데이터를 처리.</p> </li> <li> <p><strong>S6</strong>: 선택 메커니즘을 통해 입력 데이터 <em>x</em>에 따라 매개변수들이 동적으로 변화하기에 데이터의 특성에 따라 각 시점에서 필요한 정보를 선택적으로 처리할 수 있음.</p> </li> </ul> </li> <li> <p><strong>시간 불변성(Time-invariant) vs 시간 가변성(Time-varying)</strong></p> <ul> <li> <p><strong>S4</strong>: 시간 불변적인 구조로, 동일한 파라미터가 모든 시점에 적용. 이 덕분에 합성곱(convolution) 연산 가능</p> </li> <li> <p><strong>S6</strong>: 시간 가변적인 구조로, 입력에 따라 매개변수들이 변화하고, 재귀적 방식으로 계산이 이루어짐. 이를 통해 시퀀스의 각 시점에서 중요한 정보는 기억하고, 불필요한 정보는 무시하는 선택적 처리가 가능해짐.</p> </li> </ul> </li> <li> <p><strong>효율성</strong></p> <ul> <li> <p><strong>S4</strong>: 시간 불변성을 유지하는 SSM은 계산의 병렬화가 가능하여, 비교적 효율적인 계산을 수행할 수 있음</p> </li> <li> <p><strong>S6</strong>: 선택 메커니즘을 추가함으로써 더 많은 계산이 필요+system matrices가 더 이상 입력에 독립적이지 않으므로 미리 global하게 적용될 수 있는 kernel을 만드는 것이 불가→ convolution을 통한 학습 병렬화가 어려워짐에 따라서 계산 효율성을 유지하기 위해서 추가적인 대응이 필요</p> </li> </ul> </li> </ul> <h3 id="3-efficient-implementation-of-selective-ssms">(3) <strong>Efficient Implementation of Selective SSMs</strong> </h3> <p>어떻게 하드웨어의 메모리 계층을 최적화하여 선택적 상태 공간 모델의 성능을 극대화할 수 있는가?</p> <p>추가적인 대응:</p> <ol> <li> <p>연산의 associativity를 이용해 parallel scan!</p> </li> <li> <p>GPU의 메모리 계층을 활용한 하드웨어 최적화</p> </li> <li> <p><strong>Selective Scan &amp; 시간 가변적 선택 처리</strong></p> </li> </ol> <ul> <li> <p>Selective SSM은 시간 가변적이기 때문에, <strong>각 시점마다 다른 방식으로 데이터를 처리</strong>합니다. 이로 인해, 각 시점에서 중요한 정보를 선택적으로 처리하고, 재귀적 연산(recurrent operation)을 통해 이전 상태를 기반으로 다음 상태를 계산합니다.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">Selective Scan</code>은 시퀀스 내에서 <strong>중요한 정보를 선택적으로 처리하고, 불필요한 정보는 무시하는 과정</strong></p> </li> <li> <p>이때 각 시점에서 입력 데이터를 분석하여 중요한 정보만 선택적으로 처리하여 각 시점에서 처리되는 데이터의 양이 줄어들기 때문에, 메모리 사용과 계산 자원을 절약할 수 있습니다.</p> </li> </ul> <ol> <li><strong>Parallel Scan Operation</strong></li> </ol> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_027.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li> <p>병렬 스캔 알고리즘(Parellel Scan Operation)은 <strong>Selective Scan 계산</strong>을 **병렬로 처리 **할 수 있도록 설계한 것</p> </li> <li> <p><strong>결합규칙(association rule)</strong> 기반 접근법을 사용하여 “먼저 계산할 수 있는 것은 계산해주자!” 라는 간단한 방법을 사용.</p> </li> </ul> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_028.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ol> <li><strong>Hardware-Aware State Expansion</strong></li> </ol> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_029.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>다들 아시다시피, GPU는 즉각적인 데이터 접근이 가능한 고속 메모리(SRAM)와 대용량 메모리(HBM)를 가지고 있습니다. 그리고, FlashAttention에서도 언급되었듯이, GPU의 주요 병목 현상은 SRAM과 DRAM 사이의 Copy and PASTE에서 발생합니다.</p> <p>S6에서는 <strong><em>FlashAttention</em></strong>에서 나온 <strong>Kernel Fusion</strong>을 사용하여 계산의 속도를 올립니다.</p> <p>즉, 입력 벡터와 가중치 매개변수를 고성능 메모리로 전송한 후 모든 계산을 한 번에 처리하고, 다시 메인 메모리로 데이터를 전송합니다.</p> <ul> <li>이로 인해 데이터 전송 시간은 그대로 유지되면서도 16배 확장된 벡터를 사용하는 데 필요한 추가 계산 시간을 사용할 수 있게 됩니다.</li> </ul> <p>→ 즉, 계산 자체의 효율성을 개선할 수 없으니 총 시간이라도 줄여보겠다!</p> <h2 id="mamba-아키텍처"><strong>Mamba 아키텍처</strong></h2> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_030.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Mamba 블록은 MLP 블록과 대부분의 SSM 아키텍처의 기초가 되는 H3 블록을 조합한 것!</p> <p>여러 개의 Mamba 블록을 반복적으로 쌓아 모델의 깊이를 확장할 수 있습니다.</p> <ul> <li> <p><strong>구성 요소</strong>:</p> <ul> <li> <p><strong>SSM</strong>: 시퀀스 데이터를 처리하는 역할.</p> </li> <li> <p><strong>Conv</strong>: 합성곱 층이 추가되어, 시퀀스 내의 국소적인 정보 처리에 기여.</p> </li> <li> <p><strong>활성화 함수(SiLU/Swish)</strong>: H3와는 다르게, <strong>곱셈 게이트 대신 활성화 함수 사용</strong>. 곱셈 게이트 대신 비선형 활성화 함수(SiLU 또는 Swish)를 사용하여 계산 복잡성을 줄이고 데이터의 표현력을 높임.</p> </li> </ul> </li> </ul> <h3 id="성능">성능</h3> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_031.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Mamba는 Transformer보다 5배 빠른 추론 속도를 보이며, 메모리 사용량도 적습니다.</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_032.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <hr> <h1 id="5-mamba2---transformers-are-ssms-generalized-models-and-efficient-algorithms-through-structured-state-space-dualityicml-2024"><strong>5. Mamba2 - Transformers are SSMs: Generalized Models and Efficient Algorithms Through Structured State Space Duality(ICML, 2024)</strong></h1> <p>이 논문에서는 <strong>Structured State-Space Duality, SSD</strong> 개념을 제안하여, SSM과 Transformers의 attention 메커니즘이 서로 밀접한 관계를 가지며 특정한 수학적 변환을 통해 연결되고, 따라서, 그 동안 진행되었던 다양한 최적화 기법을 적용할 수 있음을 보입니다.</p> <p>또한, SSM의 선형적 구조를 1-Semiseparable 행렬로 변환함으로써 단순 행렬 곱셈으로 치환 → 병렬화로 이어져 속도를 올릴 수 있음을 보입니다.</p> <ul> <li> <p>Research Questions:</p> <ul> <li> <p>What are the conceptual connections between state space models and attention? Can we combine them?</p> </li> <li> <p>Can we speed up the training of Mamba models by recasting them as matrix multiplications?</p> </li> </ul> </li> </ul> <h2 id="1-state-space-models-are-structured-matrices"><strong>1. State Space Models are Structured Matrices</strong></h2> <blockquote> <p>SSM과 Structured Matrices</p> </blockquote> <h3 id="0-ssm을-수학적으로-정의하는-방식">0) SSM을 수학적으로 정의하는 방식</h3> <p><strong>✅ 정의 2.1: 시퀀스 변환 (Sequence Transformation)</strong></p> <ul> <li> <p>SSM은 입력 시퀀스 X를 출력 시퀀스 Y로 매핑하는 함수입니다.</p> </li> <li> <p>여기서 X, Y \in \mathbb{R}^{T \times P} 이며, θ는 학습 가능한 파라미터 집합.</p> </li> </ul> <p>✅ 정의 2.2: SSM 연산자 (SSM Operator)</p> <ul> <li>SSM을 연산자로 정의할 때, 특정한 <strong>행렬 연산</strong>을 수행하는 함수로 표현될 수 있음.</li> </ul> <p>Y=SSM(A,B,C)(X)</p> <p><strong>✅ 정의 2.3: 행렬 변환 (Matrix Transformation)</strong></p> <ul> <li>SSM을 하나의 행렬 연산으로 표현할 수도 있음.</li> </ul> <p>Y = M_\theta X</p> <ul> <li>이때, Mθ는 특정한 구조화된 행렬 (Structured Matrix)이며, 이를 이용해 연산을 최적화할 수 있음.</li> </ul> <blockquote> </blockquote> <h3 id="구조화된-행렬이란"><strong>구조화된 행렬이란?</strong></h3> <p>일반적인 T×T 행렬은 O(T^2)개의 매개변수를 필요로 하며, 이는 계산 비용이 큽니다.</p> <p>하지만 <strong>구조화된 행렬</strong>은 특정한 구조를 가지므로, <strong>더 적은 매개변수</strong>로 표현할 수 있으며, 연산 속도를 개선할 수 있습니다.</p> <p><strong>예시: Semiseparable Matrices (준분리 행렬)</strong></p> <ul> <li> <p>Semiseparable 행렬은 특정한 계층적 구조를 가지며, <strong>효율적인 행렬 연산을 가능하게 함</strong>.</p> </li> <li> <p>SSM의 핵심 연산이 <strong>Semiseparable 행렬 연산과 동일</strong>하다는 점을 논문에서 증명.</p> </li> </ul> <h3 id="1-state-space-models의-행렬-변환-형태">1) <strong>State Space Models의 행렬 변환 형태</strong> </h3> <p>논문에서는 <strong>SSM을 하나의 행렬 변환(Matrix Transformation)으로 표현할 수 있음을 보입니다</strong>.</p> <p><strong>SSM 기본 수식</strong></p> <p>SSM은 다음과 같은 순차적(재귀적) 수식으로 정의됩니다:</p> <p>h<em>t = A h</em>{t-1} + B x_t</p> <p>y_t = C^T h_t</p> <p>이를 풀어쓰면:</p> <p>h<em>t = A_t A</em>{t-1} … A<em>1 B_0 x_0 + A_t A</em>{t-1} … A<em>2 B_1 x_1 + … + A_t B</em>{t-1} x_{t-1} + B_t x_t</p> <p>이제 이를 벡터화하여 <strong>행렬 연산(Matrix Multiplication)</strong>으로 표현할 수 있습니다:</p> <p>y = SSM(A, B, C) (x) = M x</p> <p>여기서,</p> <ul> <li> <p>M은 SSM을 나타내는 특정한 <strong>구조화된 행렬</strong>입니다.</p> </li> <li> <p>이 행렬은 특정한 수학적 성질을 가지며, <strong>SSM을 효율적으로 계산하는 방법을 찾는 것이 가능</strong>해집니다.</p> </li> </ul> <h3 id="2-semiseparable-matrices-준분리-행렬">2) Semiseparable Matrices (준분리 행렬)</h3> <p>논문에서는 <strong>SSM이 Semiseparable 행렬과 동일한 구조를 가진다</strong>는 점을 증명합니다</p> <p><strong>✅ 정의 3.1: Semiseparable 행렬</strong></p> <ul> <li> <p><strong>Semiseparable 행렬</strong>은 특정한 부분 행렬(submatrix)이 <strong>낮은 랭크(rank)를 가지는 구조화된 행렬</strong>.</p> </li> <li> <p>구체적으로, <strong>하삼각(lower-triangular) 행렬의 모든 부분 행렬이 최대 N의 랭크를 가짐</strong>.</p> </li> <li> <p>즉, 행렬 내의 각 작은 블록들이 <strong>낮은 차원의 정보만 유지하면서도 원래 행렬의 주요 특성을 보존하는 특수한 구조</strong>를 가짐.</p> </li> <li> <p>이러한 행렬 구조를 이용하면 <strong>연산량을 크게 줄일 수 있음</strong>.</p> </li> </ul> <h3 id="21-the-sequentially-semiseparable-sss-representation">2.1 The Sequentially Semiseparable (SSS) Representation</h3> <p><strong>✅ 정의 3.2: Sequentially Semiseparable (SSS) 표현</strong></p> <ul> <li> <p>하삼각 행렬 M이 <strong>SSM과 같은 연산을 수행할 수 있도록 다음과 같이 정의</strong>할 수 있음:</p> <ul> <li>A lower triangular matrix 𝑀 ∈ R (T,T) has a N-sequentially semiseparable (SSS) representation if it can be written in the form M<em>{ji} = C_j^T A_j A</em>{j-1} … A_{i+1} B_i</li> </ul> </li> <li> <p>SSM의 행렬 연산을 특정한 Semiseparable 행렬 구조로 표현 가능함</p> </li> </ul> <p>𝑀 = SSS(𝐴<em>{0:T}, 𝐵</em>{0:T},𝐶_{0:T}).</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_033.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li>즉, <strong>SSM의 수식을 Semiseparable 행렬의 행렬 곱셈으로 변환할 수 있음</strong>.</li> </ul> <p><strong>✅ 정의 3.3: An N-SSS matrix 𝑀 with representation (4) is N-semiseparable.</strong></p> <p>(생략)</p> <p><strong>✅ 정의 3.4: Every N-semiseparable matrix has a N-SSS representation</strong></p> <p>(생략)</p> <h3 id="22-1-semiseparable-matrices-the-scalar-ssm-recurrence-semiseparable-matrices-the-scalar-ssm-recurrence">2.2 1-Semiseparable Matrices: the Scalar SSM Recurrence Semiseparable Matrices: the Scalar SSM Recurrence</h3> <p><strong>1-SS</strong></p> <ul> <li> <p><strong>1-Semiseparable (1-SS) 행렬</strong>은 특정한 하삼각 행렬의 랭크가 <strong>1로 제한되는 특수한 경우</strong>입니다.</p> </li> <li> <p>즉, SSM의 상태 크기(state size) N=1인 경우를 의미합니다.</p> </li> <li> <p>M<em>{ji}​=a_j​a</em>{j−1}​⋯a_{i+1}​</p> </li> <li> <p>이것을 <strong>행렬 연산 형태로 표현하면</strong> 다음과 같이 나타낼 수 있습니다.</p> <ul> <li>M=1SS(a_0:T​)</li> </ul> </li> <li> <p>1-SS 행렬은 다음과 같은 특정한 행렬 구조를 가집니다.</p> </li> </ul> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_034.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li>이 행렬은 <strong>각 타임스텝에서 이전 값을 누적 곱셈(cumulative product)하는 형태</strong>를 가짐.</li> </ul> <p>1-SS 행렬을 이용한 행렬 연산은 기본적인 스칼라 SSM 재귀식(Scalar SSM Recurrence)과 동일한 형태를 가집니다</p> <p>풀어쓰면:</p> <p>이것이 결국 1-SS 행렬의 행렬 곱셈과 동일한 구조를 가짐을 알 수 있습니다.</p> <p>즉, <strong>1-SS 행렬의 행렬 곱셈은 결국 단순한 스칼라 재귀(Scalar Recurrence)를 반복 수행하는 것과 동일함</strong>을 보일 수 있습니다.</p> <h3 id="3-state-space-models-are-semiseparable-matrices">3) State Space Models are Semiseparable Matrices</h3> <p>**✅ 정의 3.5: **</p> <p><strong>SSM의 변환 연산 **y=SSM(A,B,C)(x)</strong>은 Semiseparable 행렬 M과의 행렬 곱셈 **<strong>y=Mx*</strong>* 와 동일하다**</p> <p>즉, <strong>모든 SSM은 Semiseparable 행렬 변환으로 나타낼 수 있으며, 두 개념이 동등함</strong>을 의미.</p> <p>이를 통해 다음과 같은 사실이 도출됩니다.</p> <ol> <li><strong>SSM 연산을 Semiseparable 행렬 연산으로 최적화 가능</strong></li> </ol> <ul> <li>행렬 곱셈 최적화 기법을 적용하여 연산 속도를 크게 향상시킬 수 있음.</li> </ul> <ol> <li><strong>Transformer의 Attention과 유사한 수학적 표현 가능</strong></li> </ol> <ul> <li>Attention 연산도 행렬 변환으로 표현되므로, <strong>SSM을 Transformer 구조와 비교하고 최적화하는 것이 가능</strong>.</li> </ul> <h2 id="2-structured-masked-attention-generalizing-linear-attention-with-structured-matrices"><strong>2. Structured Masked Attention: Generalizing Linear Attention with Structured Matrices</strong></h2> <blockquote> <p>Linear Attention과 Structured Matrices</p> </blockquote> <p>이 섹션에서는 <strong>Transformer의 Self-Attention</strong>을 분석하고, 이를 일반화하여 **Structured Masked Attention (SMA) **개념을 도입합니다.</p> <p>특히, 기존의 <strong>Linear Attention</strong>이 수행하는 연산을 더 일반적인 <strong>구조화된 행렬 연산(Structured Matrices)</strong>을 이용해 확장하고 최적화하는 방법을 제안합니다.</p> <h3 id="attention">Attention</h3> <p>Y=softmax(QK^T)⋅V</p> <p>Autoregressive 모델에서, 과거의 정보만 사용하기 위해 **Causal Mask **(L)을 적용합니다.</p> <p>Y=(L∘QK^T)V</p> <p>여기서 L은 <strong>하삼각(lower-triangular)</strong> 행렬로, 미래 정보가 사용되지 않도록 만듭니다.</p> <h3 id="linear-attention">Linear Attention</h3> <p><strong>softmax attention의 quadratic한 계산 복잡도를 개선하기 위한 하나의 대안: linear attention</strong></p> <p>기존 어텐션에서 <strong>소프트맥스(Softmax)를 제거</strong>하고 <strong>행렬 곱셈 순서를 변경</strong>하면 연산량을 줄일 수 있음.</p> <p>Y=Q⋅cumsum(K^T⋅V)</p> <p>선형 어텐션은 소프트맥스 함수의 계산을 제거하여, 시퀀스 길이에 따라 <strong>선형적인 계산 복잡도</strong>를 가질 수 있음</p> <h3 id="structured-masked-attention-sma"><strong>Structured Masked Attention (SMA)</strong></h3> <p>논문에서는 기존의 선형 어텐션을 더 발전시켜, <strong>구조화된 마스크드 어텐션(Structured Masked Attention, SMA)</strong>이라는 새로운 개념을 도입.</p> <p><strong>SMA</strong>는 기존의 선형 어텐션의 장점을 유지하면서도, <strong>구조화된 행렬</strong>의 성질을 사용해 더 효율적인 방식으로 어텐션을 수행</p> <ul> <li> <p><strong>기존 Linear Attention은 단순히 Causal Mask L을 사용</strong>.</p> </li> <li> <p>하지만, <strong>더 일반적인 구조화된 행렬 L을 사용할 경우, 더 강력한 모델링이 가능</strong>.</p> </li> </ul> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_035.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>즉,L을 단순히 Causal Mask로 고정하는 것이 아니라, *입력에 따라 동적으로 변할 수 있는 구조화된 행렬(Structured Matrix)**로 확장할 수 있습니다.</p> <h2 id="3-state-space-duality">3. State Space Duality</h2> <p>해당 섹션에서는 <strong>SSM과 SMA(attention)가</strong> 어떻게 <strong>duality</strong> 관계를 통해 서로 연결되는지를 설명하며, 두 개념이 시퀀스 모델링에서 어떤 방식으로 상호 보완적인 역할을 할 수 있는지 설명합니다.** **</p> <ul> <li> <p><strong>SSM은 준분리 행렬(Semiseparable Matrix)로 표현 가능</strong></p> <ul> <li> <p>SSM의 기본 행렬 변환: M<em>{ji} = C_j^T A</em>{j:i} B_i</p> </li> <li> <p>만약 Aj가 단순한 스칼라라면, 이를 다음과 같이 변형할 수 있음: M = L \circ (CB^T)</p> </li> <li> <p>이는 masked kernel attention의 수식과 <strong>동일함</strong>.</p> </li> <li> <p>즉, <strong>SSM을 단순한 이차 시간 복잡도로 계산하면, 결과적으로 마스킹된 어텐션과 동일한 연산이 수행됨</strong>.</p> </li> </ul> </li> </ul> <p>→ SSM과 어텐션 기반 모델이 이론적으로 동일한 방식으로 동작한다!</p> <p>→ <strong>어텐션 기법은 본질적으로 상태 공간 모델의 한 형태</strong>임.</p> <p>→ 따라서, <strong>SSM의 선형 시간 복잡도 \mathcal{O}(T)</strong>를 활용해 <strong>효율적인 어텐션 모델을 설계할 수 있음</strong></p> <p>.</p> <h2 id="4-the-mamba-2-architecture">4. <strong>The Mamba-2 Architecture</strong> </h2> <p>Mamba-2는 <strong>SSM(Structured State Space Model)과 Attention의 연결</strong>을 바탕으로 **보다 효율적인 학습과 추론을 가능하게 하는 모델입니다. **</p> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_036.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h3 id="1-block-design">1) Block Design</h3> <p>Mamba-2의 블록 설계는 기존 Mamba 블록을 단순화하면서도 성능을 향상시키는 방향으로 변경되었습니다.</p> <ol> <li>** Parallel Parameter Projections**</li> </ol> <ul> <li> <p>기존 <strong>Mamba-1</strong>에서는 <strong>A,B,C 행렬이 입력 X에 따라 생성되었으며, 순차적인 연산(Sequential Computation)이 필요</strong>했습니다.</p> </li> <li> <p><strong>Mamba-2에서는 A,B,C,X를 블록의 시작 부분에서 동시에 병렬 생성</strong>하도록 변경하여 <strong>연산 효율성과 병렬 처리 성능을 증가</strong>시켰습니다.</p> <ul> <li> <p>즉, SSM을 순차적인 재귀 연산으로 구현하는 대신, 1-SS 행렬을 통해 병렬 행렬 곱셈으로 변환</p> </li> <li> <p>이는 <strong>Transformer의 Q,K,V 연산이 병렬로 수행되는 것과 유사한 개념</strong>.</p> </li> </ul> </li> </ul> <ol> <li><strong>Extra Normalization</strong></li> </ol> <ul> <li> <p><strong>대규모 모델에서 발생하는 학습 불안정성을 해결하기 위해 추가적인 정규화 계층을 도입</strong>.</p> </li> <li> <p>Mamba-2에서는 <strong>LayerNorm, GroupNorm, RMSNorm 등의 정규화 기법을 활용</strong>하여 학습 안정성을 개선했습니다.</p> </li> <li> <p>이는 <strong>NormFormer (Shleifer et al., 2021)</strong>에서 사용된 기법과 유사하며, <strong>SSM 구조에서도 효과적으로 적용됨</strong>.</p> </li> </ul> <h3 id="2-multihead-patterns-for-sequence-transformations">2) Multihead Patterns for Sequence Transformations</h3> <ul> <li> <p>SSM은 시간에 따른 상태를 업데이트하면서 시퀀스를 변환하는 방식.</p> </li> <li> <p>이를 <strong>멀티헤드 구조로 확장하면 여러 개의 독립적인 변환을 동시에 수행할 수 있어 모델의 표현력을 향상</strong>할 수 있습니다.</p> <ul> <li>Transformer에서 <strong>Multi-Head Attention (MHA)</strong>가 Q,K,V 행렬을 여러 개의 “헤드”로 분리하여 각각 독립적인 어텐션을 수행하는 것과 유사.</li> </ul> </li> </ul> <p><strong>(Multihead 패턴 정의)</strong></p> <ul> <li> <p><strong>멀티헤드 시퀀스 변환</strong>은 <strong>H개의 독립적인 헤드를 가지며, 전체 모델 차원 D=d_model</strong>을 유지합니다.</p> </li> <li> <p>각 헤드는 <strong>SSM 파라미터 A,B,C를 독립적으로 가질 수도 있고 공유할 수도 있음</strong>.</p> </li> <li> <p>Transformer와 마찬가지로, <strong>H가 커질수록 모델 차원이 증가</strong>하지만, 개별 헤드의 차원 N과 P는 일정하게 유지됩니다.</p> </li> <li> <p>일반적으로 <strong>N과 P를 64 또는 128로 설정</strong>하며, 모델 차원 D가 증가할 때 헤드 개수 H를 늘립니다.</p> </li> </ul> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_037.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ol> <li>** Multihead SSM (MHS) → Multihead Attention (MHA)**</li> </ol> <ul> <li> <p><strong>가장 일반적인 멀티헤드 구조</strong>로, <strong>각 헤드가 독립적으로 SSM을 수행</strong>합니다.</p> </li> <li> <p><strong>모든 파라미터 A,B,C가 독립적이며, 여러 개의 시퀀스 변환을 병렬로 수행</strong>할 수 있습니다.</p> </li> <li> <p>일반적인 Transformer의 <strong>Multi-Head Attention (MHA) 방식과 동일한 구조</strong>.</p> </li> </ul> <ol> <li>** Multi-contract SSM (MCS) → Multi-query Attention (MQA)**</li> </ol> <ul> <li> <p><strong>MQA는 inference 속도를 높이기 위한 최적화 기법</strong>.</p> <ul> <li> <strong>Key-Value(K,V)를 공유</strong>하여 캐싱 효율을 높이고, 연산량을 줄임.</li> </ul> </li> <li> <p>Mamba-2에서는 이를 <strong>SSM의 Multi-Contract 구조로 변환</strong>하여 적용.</p> <ul> <li> <strong>B (V에 해당)와 X를 공유</strong>하고, <strong>C는 각 헤드마다 독립적</strong>.</li> </ul> </li> </ul> <ol> <li><strong>Multi-expand SSM (MES) → Multi-key Attention (MKA)</strong></li> </ol> <ul> <li> <p>MKA는 <strong>각 헤드가 별도의 Key를 가지며, Value는 공유하는 방식</strong>.</p> </li> <li> <p>Mamba-2에서는 <strong>SSM에서 C와 X를 공유하고, B는 독립적으로 유지</strong>.</p> </li> <li> <p>이렇게 하면 <strong>다양한 Key를 학습하면서도, Value 공간은 공통적으로 활용 가능</strong>.</p> </li> </ul> <ol> <li><strong>Multi-input SSM (MIS) → Multi-value Attention (MVA)</strong></li> </ol> <ul> <li> <p>MQA가 <strong>Query마다 Key-Value를 공유하는 방식</strong>이라면, MVA는 <strong>Key-Value마다 Query를 공유하는 방식</strong>.</p> </li> <li> <p>Mamba-2에서는 <strong>MIS 방식으로 구현</strong>:</p> <ul> <li> <strong>B와 C를 공유하지만, X는 각 헤드에서 독립적으로 처리</strong>.</li> </ul> </li> </ul> <p>실험 결과, <strong>MVA 방식이 Mamba 모델에서 가장 효과적인 패턴</strong>으로 나타남.</p> <h2 id="5-systems-optimization-for-ssms">5. Systems Optimization for SSMs</h2> <p>Mamba-2는 병렬 처리에 적합하도록 설계되었으며, 특히 <strong>텐서 병렬화</strong>와 <strong>시퀀스 병렬화(Sequence Parallelism)</strong>를 모두 지원합니다. 이는 매우 긴 시퀀스 작업에서 각 시퀀스를 여러 디바이스에 분산시켜 병렬 처리할 수 있게 하며, 각 GPU 간의 <strong>재귀 상태(recurrent state)</strong>를 효율적으로 전송할 수 있습니다.</p> <p>또한, Mamba-2는 Transformer와 달리 시퀀스 길이에 따라 <strong>패딩(padding)</strong>을 사용할 필요가 없습니다. 대신, 각 시퀀스의 길이에 맞춘 효율적인 연산을 수행할 수 있기 때문에, 변동 길이 시퀀스를 처리할 때 더욱 높은 효율성을 보입니다.</p> <p>(자세한 내용 생략)</p> <h2 id="6-result">6. Result</h2> <figure> <picture> <img src="/assets/img/posts/2025-02-04-ssm-hippo-lssl-s4-mamba-mamba2/image_038.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </article> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <br> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'unknown-nlp/unknown-nlp.github.io',
        'data-repo-id': '',
        'data-category': 'Comments',
        'data-category-id': '',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-lang': 'en',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Jeahee Kim. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>