<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Reasoning Models Can Be Effective Without Thinking | Unknown NLP Papers </title> <meta name="author" content="Jeahee Kim"> <meta name="description" content="논문 리뷰"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://unknownnlp.github.io/blog/2025/reasoning-models-can-be-effective-without-thinking/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Unknown NLP Papers </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/books/">bookshelf</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Reasoning Models Can Be Effective Without Thinking</h1> <p class="post-meta"> Created on July 01, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/language-model"> <i class="fa-solid fa-hashtag fa-sm"></i> language-model</a>   <a href="/blog/tag/llm"> <i class="fa-solid fa-hashtag fa-sm"></i> llm</a>   <a href="/blog/tag/paper-review"> <i class="fa-solid fa-hashtag fa-sm"></i> paper-review</a>   <a href="/blog/tag/reasoning"> <i class="fa-solid fa-hashtag fa-sm"></i> reasoning</a>   ·   <a href="/blog/category/paper-reviews"> <i class="fa-solid fa-tag fa-sm"></i> paper-reviews</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p><strong>논문 정보</strong></p> <ul> <li> <strong>Date</strong>: 2025-07-01</li> </ul> <h1 id="1-introduction">1. Introduction</h1> <p>LLM을 이용해 복잡한 문제를 풀 때, 보통 우리는 “긴 chains of thoughts”를 생성하고 그것을 이용해 reflection, backtracking, self-validation 등을 수행하곤 한다 (“Thinking”). 이러한 reasoning path는 일반적으로 reward를 이용한 강화학습, 혹은 distilled reasoning trace를 이용한 finetuning을 통해서 획득되며, 이 <strong>explicit한 reasoning path가 실제로 성능에 많은 도움이 된다고 믿어져왔다</strong>. 이 때문에 inference-time compute scaling이 주된 paradigm이기도.</p> <p>하지만 저자들은 이에 대한 근본적인 질문을 던진다:</p> <ul> <li>정말로 explicit Thinking process가 상위 reasoning을 위해 필요한가?</li> </ul> <p>그리고 저자들은 사실 정교한 reasoning path은 그닥 중요하지 않다는 사실을 다양한 실험을 통해서 증명한다.</p> <figure> <picture> <img src="/assets/img/posts/2025-07-01-reasoning-models-can-be-effective-without-thinking/image_000.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>저자들은 DeepSeek-R1-Distill-Qwen을 이용해서 Thinking과 이들이 사용하는 NoThinking — 응답에 가짜 Thinking 블록을 미리 채워 넣고, 모델이 그 이후부터 이어서 답변하도록 하는 방법 — 을 비교해보았을 때, 오히려 NoThinking이 훨씬 더 성능이 좋다는 것을 보인다 (pass@k metrics).</p> <p>NoThinking은 2.0~5.1배 적은 토큰을 사용하면서도, k=1을 제외하고는 Thinking과 비슷하거나 더 좋은 성능을 보인다.</p> <p>또한, 두 접근법의 토큰 사용량을 동일하게 통제했을 때, NoThinking은 특히 low-budget 구간에서 pass@1가 Thinking보다 높았으며, k가 커질수록 성능 차이는 더 커졌다 (Figure 2).</p> <p>효율성을 체계적으로 평가하기 위해 pass@k와 평균 토큰 사용량 간의 Pareto frontier를 분석한 결과, NoThinking은 항상 Thinking보다 우수한 결과를 보였다. 이는 명시적인 추론 과정을 거치지 않더라도 NoThinking이 더 좋은 accuracy-cost tradeoffs를 가진다는 것을 의미한다.</p> <p>pass@k에서 NoThinking이 좋은 성능을 보였다는 것은, Thinking을 사용한 순차적 추론이 아닌, parallel scaling이 가능하다는 것이다. 저자들은 여러 응답을 병렬로 샘플링하고, best-of-N으로 최종 응답을 고르는 방법론을 제안한다.</p> <p>이들이 고려한 task는 두 가지이다:</p> <ol> <li> <p>tasks with perfect verifiers (e.g., formal theorem proving): 자동으로 정답 여부를 확인할 수 있는 경우</p> </li> <li> <p>tasks without verifiers (e.g., general problem solving): simple confidence-based selection strategies를 사용해야하는 경우</p> </li> </ol> <p>verifiers가 있는 경우, NoThinking이 Thinking을 가뿐히 능가했다 ( both with and without parallel scaling). 특히, 지연 시간을 7배 단축하고 총 토큰 사용량을 4배나 줄였다는 점이 이점. verifiers가 없는 경우에도 NoThinking 준수한 성능을 보인다. 예를 들어, Thinking을 9× lower latency + improved accuracy on OlympiadBench (Math)로 능가함. (Figure 3)</p> <p>요약하자면, 이 연구는 현재의 추론 모델들이 학습 과정에서 구조화된 추론 형식을 따르도록 훈련되었음에도 불구하고, 높은 성능을 내기 위해 반드시 명시적인 thinking 과정이 필요하지 않다는 사실을 처음으로 보여주고 있다.</p> <p>또한, NoThinking 방식을 병렬로 처리하면, 순차적 추론보다 더 좋은 latency-accuracy tradeoffs가 가능함을 보인다.</p> <p>전반적으로, 이 연구는 긴 thinking 과정이 과연 정말로 필요한 것인가에 대한 의문에 대한 답을 일부분 보여주고 있다고 할 수 있다!</p> <h1 id="2-related-work-and-background">2. Related Work and Background</h1> <h3 id="test-time-scaling-for-language-models">Test-Time Scaling for Language Models</h3> <ul> <li> <p><strong>Sequential approaches</strong></p> <ul> <li> <p>OpenAI o1, DeepSeek R1, Qwen QwQ.</p> </li> <li> <p>긴 chain-of-thought(CoT) 응답을 한 번의 순방향 패스에서 생성하며, 백트래킹과 검증 포함.</p> </li> <li> <p><strong>한계</strong>: 강화 학습(RL)이나 iterative self-improvement 등 비용이 큰 학습 과정 필요.</p> </li> </ul> </li> <li> <p><strong>Parallel approaches</strong></p> <ul> <li> <p>여러 후보 출력을 생성하고 선택적으로 응답 집계.</p> </li> <li> <p>ex. Best-of-N 샘플링, search-guided 디코딩 (ex. 몬테카를로 트리 탐색(MCTS))</p> </li> </ul> </li> <li> <p><strong>NoThinking의 차별점</strong></p> <ul> <li> <p>기존 연구는 명시적 thinking이 필수라고 가정했으나, NoThinking은 thinking을 생략해도 됨</p> </li> <li> <p>추가 학습, 보상, 감독 없이 경쟁력 있는 성능</p> </li> <li> <p>Best-of-N을 활용했지만 샘플링 기법 혁신이 아니라 cost-effective baseline for low-budget settings 제공이 목적</p> </li> </ul> </li> </ul> <h3 id="efficient-reasoning">Efficient Reasoning</h3> <p>recent work has explored various strategies to make reasoning in LLMs more efficient.</p> <ul> <li> <p><strong>추론 시퀀스 길이 최적화</strong></p> <ul> <li>생성되는 reasoning 시퀀스의 길이를 줄이거나 불필요한 단계를 제거해 간결한 추론을 유도.</li> </ul> </li> <li> <p><strong>강화 학습 기반 CoT 최적화</strong></p> <ul> <li> <p>강화 학습을 활용해 CoT 길이를 최적화하고 효율적인 reasoning을 학습.</p> </li> <li> <p>ex: 길이에 따라 보상을 설계해 모델이 적절한 길이의 reasoning을 생성하도록 유도 (Aggarwal &amp; Welleck, Luo, Shen, Arora, Qu 등).</p> </li> </ul> </li> <li> <p><strong>Best-of-N 샘플링을 활용한 파인튜닝</strong></p> <ul> <li>Best-of-N 방식으로 생성한 다양한 길이의 reasoning을 파인튜닝에 활용해 concise reasoning을 학습.</li> </ul> </li> <li> <p><strong>출력 방식 수정으로 reasoning 간결화</strong></p> <ul> <li>LLM이 reasoning을 latent representations 기반으로 생성하도록 학습해 더 간결한 reasoning을 유도</li> </ul> </li> <li> <p><strong>학습 없는 전략적 기준 설정</strong></p> <ul> <li>별도의 학습 없이, 프롬프트나 샘플 선택 criteria만으로 추론 전략을 가이드하는 training-free 방식</li> </ul> </li> <li> <p><strong>추론 단계 수 제한</strong></p> <ul> <li>프롬프트에 토큰 예산을 명시하거나, reasoning 단계를 적게 생성하도록 모델에 직접 지시해 추론을 간결화</li> </ul> </li> <li> <p><strong>동적 입력 라우팅으로 reasoning 복잡성 제어</strong></p> <ul> <li>입력 데이터를 작업 난이도에 따라 동적으로 라우팅해 복잡성을 조절하고, 쉬운 문제는 간단히 처리하고 어려운 문제만 깊이 추론</li> </ul> </li> </ul> <h1 id="3-nothinking-provides-better-accuracy-budget-tradeoffs-than-thinking">3. NoThinking Provides Better Accuracy-budget Tradeoffs than Thinking</h1> <p>Section 3.1: define Thinking and NoThinking</p> <p>Section 3.2: describe experimental setup</p> <p>Section 3.3: present experimental results</p> <p>Section 3.4: Discussions and Analyses</p> <h2 id="31-method">3.1 Method</h2> <p>대부분의 모델들은 보통 비슷한 구조로 generation을 한다:</p> <ul> <li> <table> <tbody> <tr> <td>reasoning process within the thinking box, marked by &lt;</td> <td>beginning of thinking</td> <td>&gt; and &lt;</td> <td>end of thinking</td> <td>&gt;, followed by the final answer.</td> </tr> </tbody> </table> </li> </ul> <p>이 구조에 기반해서 Thinking and NoThinking을 다음과 같이 만듦:</p> <ul> <li> <p>**Thinking: **the reasoning process within the thinking box, the final solution, and the final answer (Figure 1 (blue)).</p> </li> <li> <p>**NoThinking: ** explicit reasoning process 무시하고 바로 final solution and answer 만들기. thinking box를 decoding 할 때 빈칸으로 하도록 강제 (Figure 1 (orange)).</p> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;|</span><span class="n">beginning</span> <span class="n">of</span> <span class="n">thinking</span><span class="o">|&gt;</span>
<span class="n">Okay</span><span class="p">,</span> <span class="n">I</span> <span class="n">think</span> <span class="n">I</span> <span class="n">have</span> <span class="n">finished</span> <span class="n">thinking</span><span class="p">.</span>
<span class="o">&lt;|</span><span class="n">end</span> <span class="n">of</span> <span class="n">thinking</span><span class="o">|&gt;</span>
</code></pre></div></div> <table> <tbody> <tr> <td>token usage를 제어하기 위해 budget forcing technique from Muennighoff et al. (2025)을 사용 — 모델이 token budget에 도달하면, 강제로 Final Answer 만들도록 함. 만약 아직 thinking box 안에 있었다면, &lt;</td> <td>end of thinking</td> <td>&gt; 을 final answer tag 이전에 붙여서 만듬.</td> </tr> </tbody> </table> <h2 id="32-evaluation-setup">3.2 Evaluation Setup</h2> <ul> <li> <p><strong>Models</strong></p> <ul> <li> <p>DeepSeek-R1-Distill-Qwen-32B</p> </li> <li> <p>Qwen-32B-Instruct</p> </li> <li> <p>(Appendix) R1-series models at smaller scales (7B and 14B)</p> </li> </ul> </li> <li> <p><strong>Tasks and Benchmarks</strong></p> <ul> <li> <p>**Mathematical problem solving: **</p> <ul> <li> <p>For standard problem solving: AIME 2024, AIME 2025, and AMC 2023</p> </li> <li> <p>For more advanced reasoning: OlympiadBench</p> </li> </ul> </li> <li> <p><strong>Coding</strong>: LiveCodeBench</p> </li> <li> <p><strong>Formal theorem proving</strong>:</p> <ul> <li> <p>MiniF2F — for formal mathematical reasoning,</p> </li> <li> <p>ProofNet — for logic and theorem proving.</p> </li> </ul> </li> </ul> </li> <li> <p>**Metrics: **pass@k</p> <ul> <li> <p>k = {1, 2, 4, 8, 16, 32} for theorem proving datasets (MiniF2F and ProofNet)</p> </li> <li> <p>k = {1, 2, 4, 8, 16, 32, 64} for smaller datasets (AIME24, AIME25, AMC23)</p> </li> <li> <p>k = {1, 2, 4, 8, 16} for larger datasets (OlympiaddBench, LiveCodeBench).</p> </li> <li> <p>for formal theorem-proving benchmarks: pass@32 is the standard</p> </li> <li> <p>for math and coding: pass@1 (i.e., accuracy) is most commonly used.</p> </li> </ul> </li> </ul> <h2 id="33-results">3.3 Results</h2> <h3 id="thinking-vs-nothinking-vs-qwen-instruct-without-token-budget-controlled">Thinking vs. NoThinking vs. Qwen Instruct without token budget controlled</h3> <figure> <picture> <img src="/assets/img/posts/2025-07-01-reasoning-models-can-be-effective-without-thinking/image_001.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>budget forcing없이 세 경우를 비교한 결과:</p> <ul> <li> <p>MiniF2F and ProofNet에서 NoThinking은 모든 K에 대해서 Thinking과 비슷했으며, 둘은 Qwen-Instruct보다 성능 훨씬 좋았음</p> <ul> <li>NoThinking이 3.3–3.7x 더 적은 토큰을 사용하는데도!</li> </ul> </li> <li> <p>다른 데이터셋에서는 k = 1일 때는 NoThinking의 성능이 훨씬 떨어지지만, k가 커질수록 갭이 작아짐</p> </li> <li> <p>결과적으로, NoThinking은 가장 큰 k일때, 2.0–5.1x fewer tokens을 사용하는데도, Thinking의 성능을 넘거나 거의 근사함.</p> </li> <li> <p>Qwen-Instruct의 관점에서:</p> <ul> <li> <p>For AIME24, AIME25, and LiveCodeBench에서 Thinking and NoThinking이 훨씬 성능 좋음</p> </li> <li> <p>AMC23 and OlympiadBench에서는 Thinking and NoThinking과 비슷</p> </li> </ul> </li> </ul> <h3 id="thinking-vs-nothinking-with-token-budget-controlled">Thinking vs. NoThinking with token budget controlled</h3> <p>위에서 확인했듯,Thinking이 NoThinking보다 대부분의 데이터셋에서 성능이 더 좋음. 하지만, 결과적으로 Thinking이 더 많은 토큰을 사용하기 때문에 같은 토큰 수를 사용할 때 어떤 것이 더 성능이 좋은가를 비교함</p> <figure> <picture> <img src="/assets/img/posts/2025-07-01-reasoning-models-can-be-effective-without-thinking/image_002.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>결과적으로 NoThinking generally outperforms Thinking.</p> <p>특히, low-budget setting (e.g., fewer than ≈ 3, 000 tokens)에서 NoThinking은 모든 k에서 더 좋은 성능을 보였고, k가 커질수록 차이는 커졌음. 좀 더 토큰 제한을 늘렸을 때 (e.g., around 3, 500 tokens), Thinking이 pass@1에서는 더 좋았으나, k = 2부터는 다시 NoThinking이 더 좋은 성능을 보임</p> <figure> <picture> <img src="/assets/img/posts/2025-07-01-reasoning-models-can-be-effective-without-thinking/image_003.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Figure 6는 해당 데이터셋에서 사용한 가장 큰 k와 1, 그리고 token usage를 plot하면서 위의 결과를 더 잘 보여줌.</p> <ul> <li> <p>pass@k</p> <ul> <li>NoThinking이 항상 더 좋았음</li> </ul> </li> <li> <p>pass@1</p> <ul> <li> <p>NoThinking이 low-budget regime에서는 더 좋고 high-budget regime에서는 더 나빴음</p> </li> <li> <p>LiveCodeBench은 예외. 아마도 thinking box를 없애는 것이 token usage를 그렇게 많이 줄이지 못했기 때문이라고 예상됨</p> </li> <li> <p>data contamination의 위험을 예상하고, 절대 학습에 사용되지 않았을 AIME 2025를 추가함</p> </li> <li> <p>모든 new and established benchmarks의 결과가 이 트렌드가 artifacts of memorization이 아닌, generalizable model behavior임을 보여줌</p> </li> </ul> </li> </ul> <p>[요약]</p> <ul> <li> <p>reasoning models의 핵심인 thinking box를 없애도, 여전히 효과 좋음</p> </li> <li> <p>3.3–3.7x 적은 토큰을 사용하는데도 비슷한 성능 나옴</p> </li> <li> <p>비슷한 수의 토큰이라면 thinking보다 성능 좋음</p> </li> </ul> <h2 id="34-discussions-and-analyses">3.4 Discussions and Analyses</h2> <h3 id="task-specific-differences-in-nothinking-performance">Task-Specific Differences in NoThinking Performance</h3> <p>Section 3.3에서 나름 일관적인 트렌드가 보이긴 하지만, 각 벤치마크 결과를 자세히 살펴보면 조금 동작이 다름</p> <figure> <picture> <img src="/assets/img/posts/2025-07-01-reasoning-models-can-be-effective-without-thinking/image_004.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>In Figure 4,</p> <ul> <li> <p>AMC 2023는 모든 세팅에서 거의 performance gap없이 convergence를 보임. 아마도 saturation이 예상됨</p> </li> <li> <p>MiniF2F and ProofNet pass@1에서 NoThinking은 Thinking에 비해 훨씬 더 적은 토큰을 사용하면서 비슷한 성능을 냄. 하지만, 이는 단순히 task simplicity 이슈로 해석되면 안됨! 검증 결과, OpenAI’s o1과 같은 엄청 강한 모델은 MiniF2F에서 30% accuracy 밖에 안됐고, ProofNet은 모든 방법론에서 성능 낮았음. 즉, 왜 어떤 벤치마크에서는 NoThinking이 잘되었는가는 open question for future work이라는 것</p> </li> </ul> <h3 id="how-increasing-k-affects-nothinking-performance">How Increasing k Affects NoThinking Performance</h3> <p>왜 k가 늘어날수록 NoThinking이 더 좋은 성능을 보이는지 대략적인 이유를 찾아보기 위해 생성된 답변의 diversity를 측정함 — by computing the entropy of the answer distribution for each question.</p> <p>높은 mean entropy는 당연히 더 높은 overall diversity를 의미하고, lower standard deviation은 더 일관적인 것을 의미. 실험은 token budget이 제한된 환경에서 진행</p> <figure> <picture> <img src="/assets/img/posts/2025-07-01-reasoning-models-can-be-effective-without-thinking/image_005.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li> <p>엔트로피의 관점에서는 특별한 차이를 찾지 못함. 어떨 땐 NoThinking이 어떨 땐 Thinking이 더 높음</p> </li> <li> <p>variance의 관점에서 NoThinking은 항상 더 낮은 값을 보임 — 더 uniform하게 답을 내고 있다는 것.</p> </li> </ul> <p>이러한 다양성의 일관성 증가가 k가 커질수록 더 좋은 pass@k를 보이는 이유와 연관이 되어있을 것이라 예상은 한다만, 이를 이용해 성능 차이를 완전히 설명하기는 어렵다고언급</p> <h1 id="4-nothinking-makes-parallel-test-time-compute-more-effective">4. NoThinking Makes Parallel Test-Time Compute More Effective</h1> <p>우리는 지금까지 NoThinking이 k가 늘어날수록 더 이점이 늘어난다고 이야기함. 즉, NoThinking을 활용하면 parallel scaling method를 더 잘 사용할 수 있다는 것!</p> <p>Section 4에서는 accuracy vs. latency의 관점에서 어떻게 Thinking보다 더 좋은 세팅을 만들 수 있는지 논한다.</p> <h2 id="41-motivation-and-methods">4.1 Motivation and Methods</h2> <h3 id="parallel-scaling-v-sequential-scaling">Parallel Scaling v. Sequential Scaling</h3> <ul> <li> <p>Parallel scaling:</p> <ul> <li> <p>low latency: 여러 샘플을 동시에 생성하므로 지연 시간이 줄어듦 — 이는 API 호출이든 로컬 모델 서비스든 동일함.</p> </li> <li> <p>전체 지연 시간은 가장 오래 걸린 개별 샘플의 생성 시간을 기준으로 측정함.</p> </li> <li> <p>NoThinking은 low-budget 구간에서 더 좋은 성능을 보이고, k가 커질수록 성능이 향상되기 때문에, 단순한 best-of-N 방식을 사용했을 때도 정확도와 지연 시간 측면에서 더 우수한 성능을 달성할 수 있음.</p> </li> <li> <p>실제로 budget forcing과 병렬 샘플링을 적용한 Thinking, 그리고 sequential scaling 하의 full Thinking(Thinking without budget forcing)과 비교했을 때도 NoThinking이 더 나은 성능을 보였음.</p> </li> </ul> </li> </ul> <h3 id="methods">Methods</h3> <ul> <li> <p><strong>Parallel sampling</strong></p> <ul> <li> <p>병렬 샘플링은 N개의 독립적인 해답을 집계해 단일 예측을 생성하는 best-of-N 방식을 필요로 함.</p> </li> <li> <p>N개의 예측 P = {p₁, ···, pₙ}이 있을 때, best-of-N은 최종 출력을 P 중 하나로 선택함.</p> </li> </ul> </li> <li> <p><strong>검증 가능한 작업(MiniF2F, ProofNet)</strong></p> <ul> <li>Lean 컴파일러와 같은 perfect verifier f를 사용해 각 예측 p ∈ P의 정답 여부를 확인하고 최종 정답을 선택함.</li> </ul> </li> <li> <p><strong>verifier가 없는 작업</strong></p> <ul> <li> <p>**Confidence-based **</p> <ul> <li> <p>Kang et al. (2025)를 따라 self-certainty 지표를 사용하여 경량의 confidence 기반 선택 방식을 적용.</p> </li> <li> <p>self-certainty는 예측된 토큰 분포와 균등 분포 간 KL divergence를 계산해 모델의 확신도를 수치화함.</p> </li> <li> <p>예측 집합 P의 self-certainty 점수 c₁, …, cₙ를 계산한 뒤, 동일 연구에서 소개된 Borda voting 방식을 통해 최종 답변 선택.</p> </li> <li> <p>equivalence checking이 불가능한 벤치마크(LiveCodeBench)에서는 self-certainty가 가장 높은 응답을 최종 선택함.</p> </li> </ul> </li> <li> <p>**Majority voting **</p> <ul> <li> <p>정확한 정답이 존재하는 과제(수학 문제 풀이, 과학 문제)에서는 이전 연구를 따라 majority vote 기반의 결과를 보고함.</p> </li> <li> <p>예측 집합 P에서 추출한 답변 모음 {aᵢ}로부터 cons@n = argmaxₐ ∑₁ⁿ 1(aᵢ = a)로 majority vote.</p> </li> <li> <p>k &lt; N인 경우, 전체 N개 예측에서 무작위로 k개를 샘플링해 컨센를 계산하고, Monte Carlo simulation으로 여러 번 반복해 정확도를 평균하여 cons@k를 추정함.</p> </li> </ul> </li> </ul> </li> <li> <p><strong>Metrics</strong></p> <ul> <li>지연 시간(latency)은 각 데이터셋과 N회 반복 실험에서 생성된 토큰 수의 최댓값을 평균하여 정의함.</li> </ul> </li> </ul> <h2 id="42-results">4.2 Results</h2> <figure> <picture> <img src="/assets/img/posts/2025-07-01-reasoning-models-can-be-effective-without-thinking/image_006.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li> <p><strong>Tasks without verifiers</strong></p> <ul> <li> <p>Figure 7에서는 confidence-based 방식을 사용한 결과를 시각화했고, Table 2에는 선택된 실험의 ablation 결과를 제시함.</p> </li> <li> <p>Table 2에서는 Section 4.1에서 논의한 Best-of-N 방법을 비교했으며, 전반적으로 confidence-based 선택이 majority voting보다 더 우수한 성능을 보임.</p> </li> <li> <p>병렬 스케일링을 활용할 경우, 샘플 중 가장 좋은 예측을 선택해 pass@k 성능을 달성할 수 있으므로 pass@k 정확도를 pass@1의 상한으로 보고 Table 2에 포함.</p> </li> </ul> </li> </ul> <figure> <picture> <img src="/assets/img/posts/2025-07-01-reasoning-models-can-be-effective-without-thinking/image_007.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li> <p><strong>Perfect Verifiers</strong></p> <ul> <li> <p>병렬 스케일링과 결합한 NoThinking은 기존 sequential 접근법에 비해 훨씬 낮은 지연 시간+토큰 수로 유사하거나 더 나은 정확도를 달성.</p> </li> <li> <p>Figure 7의 첫 두 플롯에서 보듯 NoThinking은 Thinking과 동등하거나 더 나은 성능을 보이면서도 지연 시간이 훨씬 낮음.</p> </li> <li> <p>병렬 스케일링 없이도 NoThinking은 Thinking과 비슷한 정확도를 훨씬 짧은 지연 시간으로 달성함.</p> </li> <li> <p>병렬 스케일링과 결합할 때, NoThinking은 budget forcing과 병렬 스케일링 없이 수행한 Thinking과 유사한 정확도를 유지하면서 지연 시간을 7배 줄임.</p> </li> <li> <p>특히 MiniF2F와 ProofNet 데이터셋에서 NoThinking은 출력 토큰 수를 4배 줄이면서도 같은 정확도를 달성함.</p> </li> </ul> </li> <li> <p>**Simple Best-of-N Methods **</p> <ul> <li> <p>NoThinking은 병렬 스케일링과 confidence-based 선택을 결합했을 때, 대부분의 벤치마크에서 Thinking을 일관되게 능가함.</p> </li> <li> <p>Figure 7의 마지막 다섯 플롯은 여러 벤치마크에서 토큰 사용량을 통제한 상황에서 Thinking과 NoThinking의 confidence-based 선택 결과를 보여줌.</p> </li> <li> <p>연구는 주로 low-budget 환경에 초점을 맞추었음. 이유는</p> <ol> <li> <p>효율적인 추론에 대한 주된 관심사와 부합하고,</p> </li> <li> <p>최대 토큰 수가 너무 크면 지나치게 길고 비논리적인 출력(“babbling”)이 발생해 비교 가치가 떨어지고 지연 시간만 증가하기 때문.</p> </li> </ol> </li> <li> <p>병렬 스케일링 자체는 Thinking과 NoThinking 모두에서 pass@1 성능을 개선하지만, 모든 수학 벤치마크에서 NoThinking은 Thinking보다 항상 더 좋은 accuracy–budget tradeoffs를 가짐</p> </li> <li> <p>특히 예산 제한이 없는 full Thinking과 비교해도, NoThinking은 더 높은 pass@1 점수(55.79 vs. 54.1)를 기록하면서 지연 시간을 9배 단축함.</p> </li> </ul> </li> <li> <p>**LiveCodeBench **</p> <ul> <li> <p>NoThinking은 LiveCodeBench에서 less effective: 이는 confidence-based 선택이 정확한 일치 기준이 필요한 코딩 작업에서는 한계가 있기 때문으로 보임.</p> </li> <li> <p>이 경우 정확한 일치 기반 투표가 불가능해 self-certainty가 가장 높은 응답을 선택했는데, 이는 신뢰도가 낮아 성능이 떨어짐.</p> </li> <li> <p>Table 2에 따르면 이러한 방식은 투표 기반 방법이 가능한 다른 작업들과 비교해 일관되게 낮은 성능을 보임.</p> </li> </ul> </li> </ul> <p>[요약]</p> <ul> <li> <p>NoThinking의 pass@k 성능은 k가 증가할수록 더욱 좋아지며, 병렬 스케일링을 통해 pass@1 성능을 유사하거나 훨씬 더 낮은 지연 시간(최대 9배 감소)으로 달성할 수 있음.</p> </li> <li> <p>Verifiers가 있는 작업에서는 정확도는 비슷하거나 더 높이면서 총 토큰 사용량을 최대 4배까지 줄일 수 있음.</p> </li> </ul> <h1 id="conclusion">Conclusion</h1> <ul> <li> <p>이 연구는 동일한 모델이 긴 thinking chain 없이도, k가 증가함에 따라 pass@k에서 Thinking 방식과 동등하거나 더 나은 성능을 훨씬 적은 토큰으로 달성할 수 있음을 보여줌</p> </li> <li> <p>동일한 토큰 예산 하에서도, NoThinking은 대부분의 k 값에서 기존 Thinking 결과를 지속적으로 능가함.</p> </li> <li> <p>NoThinking을 Best-of-N 선택 방법과 결합하면, 기존 Thinking 방식으로는 달성하기 어려운 accuracy–budget tradeoffs 달성!</p> </li> </ul> </div> </article> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <br> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'unknown-nlp/unknown-nlp.github.io',
        'data-repo-id': '',
        'data-category': 'Comments',
        'data-category-id': '',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-lang': 'en',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Jeahee Kim. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>