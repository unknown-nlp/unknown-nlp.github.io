---
categories:
- paper-reviews
date: '2025-02-18 00:00:00'
description: "논문 리뷰 - LLM, \bPre-Training, MoE 관련 연구"
giscus_comments: true
layout: post
related_posts: false
tags:
- "\bpre-training"
- attention
- embedding
- llm
- moe
- paper-review
- reasoning
- rlhf
- transformer
thumbnail: assets/img/posts/2025-02-18-deepseek-v3/thumbnail.jpg
title: DeepSeek v3
---

**논문 정보**
- **Date**: 2025-02-18
- **Reviewer**: 김재희
- **Property**: LLM, Pre-Training, MoE

# 1. Intro

## Contribution

- MoE 학습 시 발생 가능한 overhead와 학습 불안정 요소 해소

- transformer 구조 변경을 통한 caching 효율화 방법론 제안

- Multi-Token Prediction을 통한 추가 학습 loss 이용

- 학습 인프라 최적화를 통한 분산학습 방법론 제안

- fill-in-the-middle 학습을 통한 추가적 모델 유연성 확보

- distillation 등을 통한 post-training 최적화

# 2. Architecture & Loss functions

## 2-1. 모델 구조

### 2-1-1. Overall Architecture

{% include figure.liquid loading="eager" path="assets/img/posts/2025-02-18-deepseek-v3/image_000.png" class="img-fluid rounded z-depth-1" %}

- 기존 transformer 구조 거의 유지

- FFNN: MoE 구조 사용 → 존재하던 방법론

- Attention: Multi-head Latent Attention(MLA) 구조 사용 → 새롭게 제안

### 2-1-2. Mixture-of-Experts

- 기존에 널리 활용되던 MoE 구조 차용

- shared expert와 routed expert로 구분하여 사용 → DeepSeekMoE 논문 결과

- routing: sigmoid 함수를 이용하여 입력값에 대한 각 expert의 활용 점수(affinity score) 산출

{% include figure.liquid loading="eager" path="assets/img/posts/2025-02-18-deepseek-v3/image_001.png" class="img-fluid rounded z-depth-1" %}

### 2-1-3. Multi-head Latent Attention

KV Caching

- K, V Caching: 생성 시 과거 시점의 k, v representation을 caching하여 연산량을 절감하는 방법론

{% include figure.liquid loading="eager" path="assets/img/posts/2025-02-18-deepseek-v3/image_002.png" class="img-fluid rounded z-depth-1" %}

- Pros: 연산해야 하는 representation이 새롭게 입력된 last token으로 매우 효율적

- Cons: 이전 시점의 모든 layer의 모든 k, v를 저장해야 함

Multi-head Latent Attention

- basic idea: caching 해야 하는 representaiton을 줄이고, 조금만 더 연산해보자

{% include figure.liquid loading="eager" path="assets/img/posts/2025-02-18-deepseek-v3/image_003.png" class="img-fluid rounded z-depth-1" %}

- (eq1) c: k, v를 생성하는 compressed latent vector (512 차원)

- (eq3) RoPE가 적용된 k vector를 별도로 생성하여 저장

- (eq2, 5)cached c vector로부터 head 별 다른 projection matrix를 이용하여 k, v 생성

- (eq3) RoPE 적용을 위해 RoPE 적용 k와 기존 k를 concat하여 사용

- 실제 attention 작업 시에는 기존 masked self attention과 동일하게 진행

## 2-2. Training Loss

### 2-2-1. Auxiliary-Loss-Free Load Balancing

- Load Balancing: MoE 구조 학습 시 각 expert 들이 비슷한 횟수만큼 학습에 활용될 수 있는 장치

- 기존 해결책: Auxiliary Loss를 이용하여 각 expert의 선택 분포를 uniform하도록 제한

- DeepSeek v3: 각 expert에 대한 bias term을 도입하여 affinity score 계산 시 활용 

- bias term은 end-to-end 학습 대상 X

### 2-2-2. Complementary Sequence-Wise Auxiliary Loss

{% include figure.liquid loading="eager" path="assets/img/posts/2025-02-18-deepseek-v3/image_004.png" class="img-fluid rounded z-depth-1" %}

- 여전히 load imbalance 문제가 발생할 수 있음 → 특히 한 sequence 내에서!

- 하나의 sequence 내에서도 Load balance 하도록 auxiliary loss term 도입

### 2-2-3. Multi-Token Prediction

- MTP: pretrain 시 next token 외에도 t+k 시점의 미래 시점 토큰도 함께 예측하도록 학습하는 것 

{% include figure.liquid loading="eager" path="assets/img/posts/2025-02-18-deepseek-v3/image_005.png" class="img-fluid rounded z-depth-1" %}

- 원 MTP 논문과 달리 MTP Module 도입

{% include figure.liquid loading="eager" path="assets/img/posts/2025-02-18-deepseek-v3/image_006.png" class="img-fluid rounded z-depth-1" %}

{% include figure.liquid loading="eager" path="assets/img/posts/2025-02-18-deepseek-v3/image_007.png" class="img-fluid rounded z-depth-1" %}

{% include figure.liquid loading="eager" path="assets/img/posts/2025-02-18-deepseek-v3/image_008.png" class="img-fluid rounded z-depth-1" %}

**Forwarding Process (MTP Module 2)**

1. module 1의 last hidden representation을 가지고 와서 RMSNorm 통과

1. t+1번째 token부터 embedding layer에 통과시켜 representation 획득 → t+2 시점의 단어 예측을 위한 추가 정보로서 활용하는 듯

1. 1과 2의 representation을 concat하여 transformer layer 및 LM Head를 통과시켜 예측 진행

# 3. Pretraining

## 3-1. Data

- 이 놈들이 데이터를 어떻게 수집했는지 밝히지 않고 있습니다… 

- 수학 및 코딩 데이터의 비중 증가

- 중국어 및 영어를 포함한 다양한 언어 데이터 포괄

### Fill-in-Middle strategy (이미 기존에 공개된 논문)

{% include figure.liquid loading="eager" path="assets/img/posts/2025-02-18-deepseek-v3/image_009.png" class="img-fluid rounded z-depth-1" %}

- Decoder-only 모델에게 문장의 시작(prefix)와 끝(suffix)를 주고 중간 부분을 생성하도록 시키는 것

- BPE 토크나이저를 사용하여 128K 보캡 구축

## 3-2. Long Context Extension

- 학습 효율화를 위해 context window 길이를 4k(14.8T token) → 23k(1000 step) → 128k(1000 step)로 점차적으로 확장

- YaRN 방식을 이용하여 extension 학습 진행

# 4. Post-Training

- RLHF 등의 학습을 진행하기 위한 레시피 제시 

## SFT

### 4-1. Reasoning Data

- 고품질의 reasoning data 확보를 위해 DeepSeek-R1 모델 활용 → R1 논문에서 자세히 소개 

- 코드/수학 등의 도메인에 대한 고품질 데이터 확보를 위해 각 도메인 별 expert 모델 학습

### 4-2. Non-Reasoning Data

- reasoning이 필요없는 creative writing 데이터는 이전 모델(DeepSeek-V2.5)를 통해 답변 생성

## RL

### 4-3. Reward Model

- Rule-based RM과 Model-based RM을 혼용하여 사용 

- GRPO를 통해 학습 진행

{% include figure.liquid loading="eager" path="assets/img/posts/2025-02-18-deepseek-v3/image_010.png" class="img-fluid rounded z-depth-1" %}

{% include figure.liquid loading="eager" path="assets/img/posts/2025-02-18-deepseek-v3/image_011.png" class="img-fluid rounded z-depth-1" %}

# 5. Experiments

## Pretrain

- 성능 킹왕짱!
